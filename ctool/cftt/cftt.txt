ｃｆｔｔ v.2.11

        Ｃソース中の関数名,マクロ名,変数名の呼び出し関係を調べるツール



□  はじめに

      よくあるタイプ?の,Ｃソース中の関数の呼び出し関係を調べてツリー表示
    や一覧表示するプログラムです。
      ただちょっと頑張ってマクロ名や関数以外（変数名）にも対応しています
    （かなり強引な扱いですが）。

      きちんと構文解析してるわけでなく、名前の後ろの()の有無等で判別する
    手抜き系のプログラムです。当然誤まった解釈をする場合も結構あります。
      完璧な動作を求めたものでなく、ソース解析（追っかけ）の手助けになる
    モノ（ヒント、目次）を生成できればいいや、というようなもんです。

      Ｃ＋＋には対応していません。



□  コマンド・ライン・オプション

    usage: cftt [-opts] <file>...

    オプション:
    -f        関数以外はtree表示で表示しない
    -k        見易さのための空行出力を抑止
    -m        ひとつのレベル(範囲)で同じ関数呼出があったときすべて表示
    -n        .t03 .t04出力で名前だけにする(タグファイル形式にしない)
    -v<N>     ﾌｧｲﾙ名の桁数(N:0-80)
    -r<func>  tree表示のルートの関数名を指定(省略時:main)
    -o<path>  結果を<path>に出力
    -e<path>  経過メッセージを<path>に出力
    @<path>   ﾌｧｲﾙ名,関数名を<path>より入力(@のみ標準入力)
    +<path>   ﾌｧｲﾙ名,関数名を<path>より入力(+のみ標準入力)

    なお、cftt.exe と同じディレクトリに cftt.cfg も置いてください。
  （名前を変えたときは、その名前で拡張子を .cfg にしてください。例えば、
    cftt386.exe なら cftt386.cfg です）



□  基本的な使いかた（レスポンス・ファイルを使わない場合）

  1)  簡単な使い方としては、

        ex> cftt main.c subr1.c subr2.c

    のようにすれば、main をルートにしたツリー表示と親子関係を表示します。


  2)  -o を使い、

        ex> cftt -okekka main.c subr1.c subr2.c

    のようにすれば、以下の４ファイルを生成します。

        kekka.t01       ツリー表示
        kekka.t02       親子表示
        kekka.t03       変数、関数、マクロごとの名前一覧
        kekka.t04       ファイルごとの、名前一覧

  3) -r を使い、もし xxx(), yyy() という関数があったとすると、

        ex> cftt -rxxx -ryyy -rmain main.c subr1.c subr2.c

    とすれば、ツリー表示において、xxx をグループ１, yyyをグループ2, main
    をグループ3 として、３つのかたまりを表示します。
      解析していく途中で、深すぎるツリーや、まとまった集団を抜き出すとき
    に指定するのを想定しています。



□  レスポンス・ファイルを使う場合

        ex> cftt @resfile[.cft]

      というようにしてレスポンス・ファイルを用いることができます（ @の代
    わりに + を用いることもできます）。（当然、cftt @res -f -v12 のよう
    にレスポンスファイル外にもオプション等も指定できます）

      このレスポンス・ファイル中の記述は基本的にはコマンドラインの記述の
    延長で、空白や改行で区切ってオプションやファイル名を記述していきます。
    ファイル中 ;が現れるとそれ以降改行までをコメントとして読み飛ばします。

      また、@で始まるいくつかの特殊な指定ができます。


    ○  @word

        この命令が現れると次の行からの単語は、ソース解析する上で無視する
      名前として扱われます。
        if や int 等Ｃの予約語は無視するようになっていますが、それと同じ
      扱いをする名前をここに記述します。

        cfttではユーザ定義な型名をちゃんと処理しないので（変数として扱わ
      れる可能性大）、型名や頻出しすぎて解析の邪魔になる名前とかをここに
      記述しておくのを想定しています。

      なお、struct や union, enum の直後の名前は自動的に無視する単語とし
      扱っていますが、typedef された名前については変数と区別出来ず同じ扱
      いをしています。


    ○  @file
        これ以降の単語はファイル名として扱います。
        レスポンス・ファイル入力開始時はこのモードです。


    ○  @group  補足説明
        この命令が現れると次の行からの単語はファイル名でなく、ルートとな
      る関数名として扱われます。
        -rオプションの変形ですが、-rオプションの場合、一つの関数名につき
      グループ番号を与えますが、この@group指定では次の@group指定が現れる
      までグループ番号を更新しません。
        ライブラリを一塊にしてグループ分けするのを想定しています。

      なお、@groupの後ろに補足説明を書いておけば、ツリー表示においてグル
      ープ先頭に一緒に表示されます。


    ○  @comment

        この命令が現れると次の行からの単語は、１行２単語を単位として、
            name        簡単な説明                  ~~~~
      のように指定すれば、name（関数名、変数、マクロ）に簡単な説明を与え
      ツリー表示や親子表示等でその名前が現れるたびに、一緒に表示します。

        ただ指定にはちょっと問題があり、簡単な説明の途中に空白(' 'やタブ,
      改行等)を含めることはできません。注意してくだい。



□  .cfg ファイルについて

      cftt.exe と同じディレクトリにおく cftt.cfgファイルですが、これは、
    レスポンス・ファイルと同じ記述方法で、毎回設定するようなオプションや
    削除文字列等をここに記述しておいてください。



□  ツリー表示のみかた(.t01ファイル)

        ex.c   123 :   1.0000 ﾌ main
        ex.c   456 :   1.0001 |--ﾌ a
    ex_sub.c    78 :   1.0002 |  |--ﾌ b
        ex.c   123 :          |  |  |--ﾌ a    1.0001
                              |  |
        ex.c   910 :   1.0003 |  |--ﾌ c
                              |
    ex_sub.c    11 :          |--ﾌ sub        2.0000
                                 :
                                 :
    ex_sub.c    11 :   2.0000 ﾌ sub
    ex_sub.c    78 :          |--ﾌ b          1.0002
                                 :
                                 :
    （ﾌｧｲﾙ名 行番号:    番号1  名前            番号2）


    のように、呼び出し構造をツリー状に段付けして出力します。

      ファイル名はその名前が定義されているファイルのことで、行番号はその
    定義のある行番号です。

    ルートになる名前(省略時 main)が見つからない場合、tree表示されません。

      名前の左右どちらかにある番号はツリー表示でのその名前の番号です。
      基本的にその名前がツリー表示で初めてあらわれたとき、名前の左側に番
    号(番号1)がつき、２度目からは右側(番号2)につきます。  １度目の表示で
    その名前より下の表示を行ない、２度目からはおこないません。

      基本的にはツリーごとに番号の ｢.｣の左の値（グループ番号ということに
    する）は更新され、右の値はクリアされます。ただし @group １つに対し複
    数のルートを指定していればグループ番号の更新は行なわれず直前の続きの
    番号となります。ただルートとなる名前はその表示が行われる前に参照され
    ると｢.｣の右の値は確定していないので値のかわりに'????'が表示されます。

    名前の直前に ﾌ ﾗ ﾏ ﾍ が付きますが、これらは、

        ﾌ       ファンクション名：ソース中に定義のあった関数名
        ﾗ       ライブラリ関数：プロトタイプ宣言だけの関数名
        ﾏ       マクロ名：#defineで定義されたマクロ名
        ﾍ       変数：その他（たいていは変数）の名前

    を意味します。また、

        a.c    18 :   2.0015    ﾏ IsKanji ｸﾞ ﾀ

    のように名前の後ろに ｸﾞ や ﾀ がつく場合がありますがこれは、

        ｸﾞ      グローバル：複数のファイルにまたがって使われている。
        ﾀ       多重定義：複数箇所で定義されている。
                        （複数ファイル入力で static 定義された名前が同じ
                          だったり、#if 等で複数パターン用意された場合な
                          どのとき発生）

    という意味です。



□  親子関係の表示(.t02ファイル)

      その名前を呼び出す名前を'親'、その名前が呼び出す名前を'子'、として
    表示します。

  （ﾌｧｲﾙ名 行番号:   番号1       名前            ）
     ex1.c    12 :   1.0001    ﾌ funcA
     ex1.c   345 :         母親    ﾌ funcB
     ex2.c    67 :         父親    ﾌ funcC
     ex1.c    89 :           娘    ﾌ funcD
     ex2.c   101 :           子    ﾌ funcE
     ex2.c   213 :       実の子    ﾌ funcF
     ex1.c   345 :         ◎娘    ﾌ funcB
  （ﾌｧｲﾙ名 行番号:       (関係)      名前）

      ファイル名はその名前が定義されているファイルのことで、行番号はその
    定義のある行番号です。
    １行目の名前の左の番号1 はツリー表示で割り振られた番号です。

    '母親'や'娘'などの印の意味はこの例をつかってを説明すると、

     母親     名前 funcA は同じファイルにある名前 funcB から呼ばれる
     父親     名前 funcA は別のファイルにある名前 funcC から呼ばれる
       娘     名前 funcA が同じファイルにある名前 funcD を呼び出す
       子     名前 funcA が別のファイルにある名前 funcE を呼び出す
   実の子(娘) 名前 funcF は(自分の他は)名前 funcA からしか呼ばれない
     ◎娘(子) 名前 funcB と名前funcA は互いに呼びあう.
              つまり funcB は funcA にとって'親'でもあり'子'でもある…

  となります。



□ 解析の動作

      このプログラムはソースファイルの詳細な解析は行なっておらず、名前の
    後ろに ( があれば関数、なければ変数として、また #define 定義された名
    前はマクロとして扱います。もちろん if,for等の予約語は無視します。
      ｢{｣と｢}｣の出現をチェックし、{ } に囲まれていない範囲(０レベル)で名
    前が現れれば定義、０レベル以外ならば参照として処理します。

      処理は２パスで、最初に定義される名前を調べ登録し、次に名前の参照箇
    所を調べそれが定義済みの名前なら、呼出（被呼出）として登録します。
    従ってソースで定義されていない名前は登録されません。

      ソースの解析を行なっているわけでないので、当然、手続き内で宣言され
    た名前や、構造体のメンバ名等にグローバル名と同じ名前があれば、誤認し
    て、参照処理されてしまいます。名前のstatic宣言を行なっているばあいな
    どでは重複定義がおこるばあいもあります。名前の重複定義があったときは、
    そのことを表示して二回目以後の定義は無視します。

      参照処理ですが、関数名に限らず０レベルでの定義名の後に { } があれ
    ばその中身はその定義名に参照されたものとして扱います。おかげでジャン
    プテーブルをそれなりに処理できます。反面、構造体定義とかがあると、そ
    の直前の変数なりマクロ名なりに誤って関連づけてしまう場合もあります。

      あと、void (*name)(); のような複雑な定義の類ですが、最初の()括弧に
    関しては一重括弧で運がよければ強引に無視して関数と認識するようにして
    います。

      ｢#｣で始まる行については、#if, #ifdef, #ifndef, #elif, #else はそれ
    が現れたときの｢{｣のレベルを控え、対になる #elif, #else, #endif が現
    われるまでそのまま処理を行ない、あらわれた時点でレベルが変化していれ
    ばその旨を表示します。その他の#で始まる行はその行を無視します。

      ソースがおかしかったり、なんらかの都合(#if など)で読込みがずれ｢{｣
    のレベルがあわなくなったりして、おかしな場所でEOFが現れると処理を中
    断します。



□  配布条件等

    フリーソフトウェアです。パソ通(ｵﾝﾗｲﾝ) での非営利配布ならば作者に連絡
  不要で再配布していただいてかまいません。その他の場合（雑誌紹介とかディ
  スク配布で同梱したいなど）事前に相談ください、ってことで（配布圧縮ファ
  イルの内容をかってに改編しないこと）

    djgcc や watcom-c v10.5j その他でも再コンパイルできますが、とりあえず、
  配布ファイル中の実行ファイルは  borland Bcc32 v5.2 と bcc v4.52 でコン
  パイルしたものを同梱しています。

    でもって作者はいかなる責任も義務も負いません。とにかく使うならば利用者
  の責任で用いてださい、ってことで。

    営利配布は自由でないですが、営利利用（仕事場で業務に使うとか）はもち
  ろん構いません。

    ソースですが、原作者を含め第三者のプログラミングを阻害しない人に限り
  流用や改造は自由です（改造部分の著作権でもって他者の利用を制限するとか
  いう人は駄目です）
    直接的な改造物を再配布したい場合は改造物であることを明示し配布条件を
  原作者と同じにしてください。ささいな流用程度ならば出所明記は特には不要
  です。



□  終わりに

      結構前に作ったもので、その後、機能を追加したり変更したり削除したりと、
    気が向いたときにその都度強引な改造を続けたおかげで、不要なルーチンが残っ
    てたり今みると何ってるのかようわからん部分があったり、辻褄あってるのか
    不安なところがあったり、と、結構怪しい代物です^^;
    （名前の解析処理や表示のしかた等作りなおしたいと思う部分が多々ある）

      実際のとこ、使ってて static 関数や変数で同じ名前の定義が複数あるとき
    ちゃんと名前範囲を区別できない、ってのは結構面倒、てか致命的な欠点かも。
    多重定義かどうかのチェックがあるので多少ましかもだけど。

      例によって十分なチェックなんて行ってるわけないので、気をつけてくだ
    さいませ。


                                       てんか☆ (きたむらまさし)
                                       tenk@prisma.co.jp
                                       NIFTY NBB00541
