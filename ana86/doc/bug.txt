■■■■■                    よくやるバグ                         ■■■■■

  以下のものは、ana でプログラムを組むと、よくやってしまう失敗例です。
  （はっきりいって、仕様が悪い！のですが^^;）
  

□　import してるのに import できない... 輸出する宣言に'*'を付けわす
    れている^^;


□　loop.w であって、endloop.w はない。


□　Ｃの関数を作ったときに、cdecl を指定しわすれる。

    スタックに積まれた引数は通常、手続き側で削除して戻りますが、Ｃで
  は呼びだし側で削除することになっているので、手続き側では削除しない
  よう cdecl を指定する必要があります。
    これは、いろいろ悩んだあげく出力されたソースをながめて、ret 4 と
  かを見るまできずかなかったりします(^^;

    なお、モジュール先頭での c_name での第３引数は、単に、生成する名
  前がＣ用に'_'を付けるかどうかの指定のみで、cdeclとは関係ないので
  間違えないでください。


□　enter を指定しているつもりが begin を指定している。

    begin を指定できるのは、スタックに確保された領域をアクセスしない
  ばあいのみです。スタックに詰まれた手続き引数や、ローカル変数、あと
  save 命令でセーブしたレジスタに名札を付けてアクセスするばあいは、
  enter を指定しなければいけません。
    今はチェックしてある程度エラー表示するようになっていますが...



■■■■■  現在わかっているけど直せないａｎａのバグ（転じて仕様）  ■■■■■


□　条件分岐の条件で !(not)を使うとエラーが出る場合があるというバグ

      &&,|| を並べたばあい以下のように、'!' を用いるとエラーになるば
    あいがあるというバグがあります。
        例） go (ax == 0 && !(bx == 0 && cx == 0)) LBL
    これは、 go (ax == 0 && (bx != 0 || cx != 0)) LBL
    のように展開してやれば回避できます。 
    
    '!' が現れるのが(条件)の一部の条件に付いたときだけみたいで、
        例） go !(si && (di == 0 || cx)) LBL
             go (si && !di || cx == 0) LBL
    のような全体に対して、とか、一つだけ、なら、大丈夫です。
    （が、よくわかりません）


□　手続きやww()の引数で、lea を生成するばあいのバグ

　　　手続きのワード・レジスタの引数やww()の引数で　bp - 10 というよ
    うな指定をすると、本来ならlea のオペランドとなる間接アドレッシン
    グを生成しなければならないのですが、 あやまって cmp を生成する可
    能性があります。
    そういう指定をしたいばあいは &b[bp - 10]というふうにしてください。


□　al = b[bx + al]のセグメント・オーバーライドができない

    al = b[es:bx + al]のような、セブメント・オーバーライド指定はでき
    ません。
    もちろん、seg_es 等を用いれば可能です...
    xlatがセグメント・オーバーライドできるなんて思ってなかったんです^.^;）


□　あまり大きなソースは変換できない。
    どの程度のサイズまで大丈夫かはわかっていませんが^^;
    メモリの扱いがいい加減なのでメモリが足りなくなるでせう。
    メモリ不足になったら適当なサイズに分けてください。


■■■■■        チェックの甘いところ、バグのいそうなところ        ■■■■■

  いっぱいあるので、思い付いた一部を書き出しておきます^^;。
  はっきりいって全体的にエラーチェックは甘い（というかやってない）ば
  あいが多いので...


□　式のチェックがあまい
    とくに、メモリ・アクセスの 型[...]の[..] 内は（有効なレジスタかど
    うか等）チェックをしていません。
 
    ただし、これはたいてい出力したアセンブリ・ソースをアセンブルした
  段階でエラーになるだろうから、あまり問題でないかも。


□　名前の管理、メモリの管理がずさん。

    名前のためのメモリは当所、チョッとずつ確保するようにしていたのですが、
    メモリを追加する段階でどっかにバグが発生し、うまく機能しないので、
    まとめて最初に一定量どばっと確保するだけなので、あまり名前のための
    メモリがありません。だもんで、あまり、たくさんの外部名を import す
    るのは避けてください.


□　マクロ

    @define マクロは、proc〜macro〜endproc に挫折して、路線変更で無理
  やり付けたものなので、バッファサイズもあんまりないし、マクロ名が同名
  や互いに呼び出してネストすると暴走はしないはずだけどメモリ不足で止ま
  ってしまうはずです。
    マクロで使ったメモリの解放等をちゃんとやってない部分があるので、
  使えば使うほどゴミが残るかもしれません（どう実装したか忘れた^^;）
    @define マクロは多様すると、なんとなく気持ちわるいです。定数や
  defined()チェックならば、const や @set で十分まにあいますのでそちらを
  使いませう。


□  合成命令
      ほぼ大丈夫だとはおもっていますが、ものによっては考えてみただけで
    実際に使ったことないものもあるので（特にシフト命令 の 5回以上のシ
    フトは自身ない）、奇特な方はぜひ、合成命令が正しいか確かめてやって
    ください。
    まあ、パズル気分で考えると楽しいのでは^_^;

