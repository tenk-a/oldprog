#3.1　ファイル
  　
　　ＡＮＡのソース・ファイルには、実際のコードとなる手続きがかかれるファイル
　と、いくつかのソースファイルで共通につかう変数や手続きを宣言しておくヘッダ・
　ファイルがあります。
　　ひとつのファイルにある手続きをまとめてモジュールということにし、いくつか
　関係のあるモジュールをまとめてグループとしてあつかい、ヘッダ・ファイルでは
　このグループ内で使われる変数の定義や他のモジュールから呼ばれる手続きの宣言を
　行います。モジュールのかかれたファイルをMODULEファイル、ヘッダ・ファイルを
　グループ定義ファイルとします。
　　
　　グループ化を行うと所属するモジュールは共通のコードセグメント、データセグメ
　ントに配置され、グループ内では nearアクセス, nearコールになります。当然なが
  らグループ全体でデータ、コードそれぞれ６４Ｋバイト以内に納まらないといけま
  せん。


#3.1.1 モジュール・ファイル
　　
　　ファイルは module文 ではじまり end module文でおわり, コンパイルすると、ひと
　つの.OBJファイルが作成されます。

    module <MODULE名>,<所属ｸﾞﾙｰﾌﾟ名>;
	include ｸﾞﾙｰﾌﾟ名;	//使用するﾗｲﾌﾞﾗﾘのｸﾞﾙｰﾌﾟを指定する。

	<enum 定数名定義>
	<const 定数名定義>
	<static  変数定義>
	<var 変数定義>
	<far var 変数定義>
	<procdef 手続き宣言>
	<proc 手続き定義>
	<procedure  手続き定義>
	<common procedure 定義>
    end module;

  　<MODULE名>はその moduleの名前です。いまのところこの名前を参照するような
  ことはありませんが、とりあえず、ファイル名をかいておいてください。

　　<所属ｸﾞﾙｰﾌﾟ名>は, そのモジュールが所属するグループ名です。

　　include文はライブラリ等、所属グループ以外のグループの手続きや変数を使う場
　合に必要なグループ名を指定します。

　　module内の変数や定数の定義やproc宣言された手続きは、そのモジュール内でしか
  使えず、他からは参照できません。procedure宣言された手続きはグループ内で、
  common procedure で宣言された手続きはプログラム全体からよびだせます。


#3.1.2  グループ定義ファイル

　　group文で始まり end group文でおわります。コンパイルの必要があり、コンパ
　イルすると.OBJファイルを作成します。

　　group <ｸﾞﾙｰﾌﾟ名> [,<親グループ名>[:<SEG>]];
	model <ｺﾝﾊﾟｲﾙ･ﾓﾃﾞﾙ名並び>;

	<common const 定数名定義>
	<common enum 定数名定義>
	<common var 変数定義>
	<common static 変数定義>
	<common procdef 宣言>

	<const 定数名定義>
	<enum 定数名定義>
	<var 変数定義>
	<static 変数定義>
	<procdef 宣言>
    end group;

　　グループ名はヘッダ・ファイル（拡張子除く）と同じ名前でないといけません。
　MS-DOSのファイル名は小文字がつかえないので、大文字だけの名前にしてください。

　　親グループ名は、そのグループがある特定の一つのグループからしか呼ばれない
　ときに指定してください。
　　グループごとにコードセグメント(CS), データセグメント(DS)が用意されますが、
　この親グループが指定され、親グループ名の後に':CS'がつくとCSを親グループと
　共有し、':DS'がつくとDを親グループと共有し, ':CS:DS'でCS,DSとも親グループと
　同じになります。もちろんセグメントサイズが６４Ｋ以内にならないといけません。

　　model文は、コンパイル・モデルが特定されるばあいに指定してください。指定
　ないばあいはとりあえずすべてのモデルに対応しているとします。


#3.2 コンパイル・モデル
　　グループわけは名前のスコープの管理のほかに、セグメントサイズの制限により
　セグメントを分割しなければならないようなとき、比較的楽に管理できるようにし
　ます。
　　そのため基本的にコールやアクセスはグループ内はnearで行われ、グループ間で
　はfarで行う、という考えて扱っています。
　　しかし、実際にアセンブラで64Ｋバイトをこえるようなコードを各ことはまず
　ないし、データも大きな配列を使うのでなければ、スタックとあわせて６４Ｋで
　ことたりるでしょう。

　　そこで、ソースはなるべく基本のルールにしたがい、実際のコンパイルのときに
　グループ間の変数アクセスや手続き呼び出しの効率をよくするため、セグメントを
　どのように配置するかを指定してやります。
　　もちろんアセンブラですので、これらの指定を変えるだけで自動的にそれぞれの
　モデルに対応できるわけでなく、プログラマが気をつけて（条件コンパイルなどを
　して）各モデルでコンパイルできるように書いてやらないと、一つのファイルで複
　数のモデルに対応することはできませんが。

　コンパイル・モデルには以下のものがあります。

    タイニーモデル	tiny
	CS,DS,SSを同じにしcomを作成します。
	グループ間の呼び出しをnearコール, 変数アクセスをnearアクセスにします。
	つまり、プログラムは一つのコードセグメントに配置され、データはひとつ
	のデータセグメントに配置されます。

    スモール・モデル	small
	グループ間の呼び出しをnearコール, 変数アクセスをnearアクセスにします。
	CS,DS,SSを同じにするか分離するかは別途指定できます。
　　　　デフォルトでは、DS==SS!=CSとなります。
	プログラムは一つのコードセグメントに配置され、データはひとつのデータ
　　　　セグメントに配置されます。

    コンパクト・モデル	conpacte
	グループ間の呼び出しをnearコール, 変数アクセスをfarアクセスにします。
	CS,DS,SSは別々になります。
	プログラムは一つのコードセグメントに配置され、データはグループごとに
　　　　データセグメントが用意されます。

　　ミディアム・モデル	mid
	グループ間の呼び出しをfarコール, 変数アクセスをnearアクセスにします。
	CS,DSを分離し、DSとSSを同じにするか分離するかは別途指定できます。
	デフォルトでは、DS==SS!=CSとなります。
	プログラムはグループごとにコードセグメントが用意され、データはひとつ
	のデータセグメントに配置されます。

　　ラージ・モデル	learge
	グループ間の呼び出しをfarコール, 変数アクセスをfarアクセスにします。
	CS,DS,SSは別々になります。
	コード、プログラムともにグループごとにセグメントが用意されます。

　　つまりラージ・モデルを基準としています。
　　が、コンパイルのデフォルトはスモール・モデルです。
　　group定義において指定されるmodel文のパラメータは、

	t	タイニー or スモール	CS == DS == SS 
	s1|s	スモール・モデル	CS != DS, DS == SS
	s2	スモール・モデル	CS != DS, DS != SS, CS != SS
	s3	スモール・モデル	CS == DS, DS != SS
	c	コンパクト・モデル	CS != DS, DS != SS, CS != SS
	m1|m	ミディアム・モデル	CS != DS, DS == SS
	m2	ミディアム・モデル	CS != DS, DS != SS, CS != SS
	l	ラージ・モデル		CS != DS, DS != SS, CS != SS

  　が指定できます。この名前はmodel文のみに有効で、これらの名前を他で使っても
　　名前の衝突はおこりません。



  # 型

	型名は、必ず大文字であらわされ、'_'や数字がはいるのはかまわないが、
	小文字を使うことはできません。

	基本的な型として次のものがあります。

		BYTE			1バイト
		WORD			2バイト
		DWORD			4バイト
		QWORD			8バイト
		TBYTE			10バイト
		XWORD			16バイト
		CWORD			2/4バイト (near/far ﾎﾟｲﾝﾀ)

	CWORDは、アセンブルモードが nearならWORDに、farならDWORDになります。
	もちろん、実際のプログラムでは、プログラマがifpln をもちいて、
	書き分けなければうまくいきません。

	基本型を組合せて構造体型がつくれます。

		structdef 型名 ﾒﾝﾊﾞ宣言；

	と宣言された型名がつかえます。（くわしくは、後述）

	そして、それらによる配列型ができます。

		型名[N]

	というふうに型名のうしろに[N]をつけて宣言します。Nは定数式で、型の
	サイズは 要素(型名)のサイズ* N となります。

	また、変数名の型情報を取り出し、型としてあつかえるように、

		type(変数名)

	という命令もあります。
	( ただし、変数名として配列を指定すると、その要素の型となり、配列自体
	  を型として指定できません。) // 廃案!

	あと、size(型名) で、型のサイズを値として、定数式として利用できます。
	もちろん size(変数名) も可能です。


	初期化が行えるばあい、型は初期値より定められるので、特に強制する必要
	がなければ省けます。
　　	型の判定のルールは、
　　  		0〜0xFF まで	BYTE
      		-0x7fff〜0xffff WORD
      		WORDの範囲外    DWORD
      		"文字列"        BYTE配列
    	となります。
    	QWORD,XWORD は、変数宣言等で初期化を行えません。


  # 変数

　　* [...] であらわされた変数
	[] 内で示される実行アドレスEAのメモリを変数として扱い、以後、
	変数といえば[EA]で表されるものも含みます。

	[...] で表された変数は型情報を持たないので、たいていのばあい、
	型指定をする必要があります（別記）

		[D]
		[RB]
		[RI]
		[RB+D]
		[RI+D]
		[RB+RI]
		[RB+RI+D]

	D はﾃﾞｨｽﾌﾟﾚｰｽﾒﾝﾄで定数式, RB は bx,bp, RIは si,di です。
	順番はこの順番でないといけません。
		
	一応、以下[...]として使えるものをすべて書き出してみると、

	        [D]
	        [bx]		[bp]		[si]		[di]
	        [bx+D]	        [bp+D]	        [si+D]	        [di+D]
	        [bx+si]	        [bp+si]
	        [bx+di]	        [bp+di]
	        [bx+si+D]	[bp+si+D]
	        [bx+di+D]	[bp+di+D]

	セグメントを指定するばあいは、
		[SG:EA]
	というふうに、[]のうちがわにｾｸﾞﾒﾝﾄﾚｼﾞｽﾀをかきます。
	SG:[...] という書き方はできません。
	例)
		[cs:D]
		[ds:bx+D]
		[es:di+D]
		[ss:bp+si+D]



　　* ｾｸﾞﾒﾝﾄ,ﾍﾞｰｽ,ｲﾝﾃﾞｯｸｽ･ﾚｼﾞｽﾀによる配列
	ｾｸﾞﾒﾝﾄ,ﾍﾞｰｽ,ｲﾝﾃﾞｯｸｽ･ﾚｼﾞｽﾀを[]のそとにおいやって、括弧ないは定数式
	Iのみで、
		RB[I]
		RI[I]
		RB.RI[I]
		SG.RB[I]
		SG.RI[I]
		SG.RB.RI[I]

	として、配列にしてアクセスできます。実際にアクセスされるメモリは
	型指定により決定した要素のサイズをSZとすると、

		RB[I] --> [RB+I*SZ]

	というふうに, ﾃﾞｨｽﾌﾟﾚｰｽﾒﾝﾄ D は、D=I*SZ となります。
	添字が0のばあいは、D指定のないｱﾄﾞﾚｯｼﾝｸﾞでｱｾﾝﾌﾞﾙされます。


　　* 変数宣言された変数
	宣言子　変数名:型　｛,変数名:型｝;
	例)	var Var:BYTE, Var2:WORD, Var3:BYTE[10];

	変数名は、大文字が使われるばあいは必ず同時に小文字が使われないといけ
	ません。
	また、proc内で宣言された変数は、必ず大文字が使われる前に小文字がない
	といけません。
	例)
		var  ERR	不可
		var  Ray	可
		auto Ray	不可
		auto _01	可

	* 宣言子
	宣言子は var,static,auto,cvarの４種類あります。
	var	dsｴﾘｱに配置される変数.
	static  csｴﾘｱに配置される変数.
	auto	ssｴﾘｱ(ｽﾀｯｸ)に配置される変数. bp.Var でｱｸｾｽする.
		大文字ではじめることはできません。
	cvar	実体の割り付けをおこなわない型情報つきの名前.
		ｲﾝﾃﾞｯｸｽｱﾄﾞﾚｯｼﾝｸﾞでのｱｸｾｽを想定している.
		ただし、cvar 開始値 変数名:型...;というふうにして、開始値と
		して特定のアドレスをわりあて、そこを変数として、アクセスする
		ことができます.

	* Var 変数名
        変数宣言された名前は、型情報をもち、varで宣言された名前はｸﾞﾛｰﾊﾞﾙ変数
	として変数名のみで、ローカル宣言されたものはbpつきで、static宣言され
	たものはcsつきで、cvarで宣言されれば可能な表現で、[...]表現にすること
	なくそのアドレスの中身を対象としてアクセスします。

	ﾚｼﾞｽﾀとの組合せは以下のようになります。また、[...]での表現は右のように
	なります。
		Var			type(Var) [&Var]
		RB.Var			type(Var) [RB+&Var]
		RI.Var			type(Var) [RI+&Var]
		RB.RI.Var		type(Var) [RB+RI+&Var]
		SG.Var			type(Var) [SG:&Var]
		SG.RB.Var		type(Var) [SG:RB+&Var]
		SG.RI.Var		type(Var) [SG:RI+&Var]
		SG.RB.RI.Var		type(Var) [SG:RB+RI+&Var]

	Varのまえに'&'をつけると、Varのオフセット値(アドレス)を値とします。
	このとき、型情報は失われます。
	標準的なｲﾝﾃﾙの表現とちがい、[Var]は変数Varの示すｱﾄﾞﾚｽの内容ということ
	になり、8086ではそのようなアドレッシングはないので、エラーとなります。


	* Ary 配列変数
	配列型で宣言された変数のことです。たとえば以下のように宣言されます。
		var Ary:BYTE[20],Ary2:WORD[10][10];

	つかうときは、

		Ary[I]
		Ary[J][I]
		SG.Ary[I]
		SG.RB.Ary[I]
		SG.RI.Ary[I]
		SG.RB.RI.Ary[I]

	というふうに、Aryの前にSG,RB,RIﾚｼﾞｽﾀをつけ、添字は定数式で指定します。
	ちょうどSG,RB,RIﾚｼﾞｽﾀでの配列表現で、ﾚｼﾞｽﾀの末に変数名が付加した形
	になりますが、変数名に型情報があるのでキャストの必要はありません。
	Ｃと同じように多元配列もできます。

	以下に一次元配列をかきだしてみると、
	I:添字(定数式), SZ:配列の要素のｻｲｽﾞとして、
					      | * 要素のｻｲｽﾞが1ﾊﾞｲﾄで1次元配列
        [&Ary+I*SZ]	      Ary[I]          |   のときのみ
        [RB+&Ary+I*SZ]	      RB.Ary[I]       | Ary[RB+I]
        [RB+RI+&Ary]	      RB.RI.Ary[0]    | Ary[RB+RI]	bp.Ary[RI]
        [RB+RI+&Ary+I*SZ]     RB.RI.Ary[I]    | Ary[RB+RI+I]	bp.Ary[RI+I]
        [SG:&Ary+I*SZ]	      SG.Ary[I]       |
        [SG:RB+&Ary+I*SZ]     SG.RB.Ary[I]    | SG.Ary[RB+I]
        [SG:RB+RI+&Ary]	      SG.RB.RI.Ary[0] | SG.Ary[RB+RI]	ss.bp.Ary[RI]
        [SG:RB+RI+&Ary+I*SZ]  SG.RB.RI.Ary[I] | SG.Ary[RB+RI+I]	ss.bp.Ary[RI+I]
	となります。二次元配列では、
	  I,J:添字(定数式)  SZ:配列の要素のｻｲｽﾞ	IM:Iの列のサイズ　とすると、
	[&Ary+J*IM+I*SZ]      Ary[J][I]
	というようになります。

	　Ｃとちがい、配列名でもアドレス（オフセット値）を得るには必ず&をつけ
	ないといけません。


  # 変数の型キャスト
	[...] で あらわされた変数や、型情報付きの変数を一時的に別の型で、
	アクセスしたいとき、変数のおけるところで、
		型名 変数
	とすると、変数の実行アドレスから指定した型でアクセスします。
	例）
		BYTE [bp+0x100];
		WORD BVar;
		BYTE bx.si[100];

	Cと意味が違い、式の型を変更するのでなく、変数の実行アドレスがしめす
	内容をアクセスする型を一時的に変更します。御注意ください。


  # 構造体
　　  * 構造体型宣言
	構造体型の宣言は以下のようにします。
		structdef 型名
		    ﾒﾝﾊﾞ1:型,
		    ﾒﾝﾊﾞ2:型,
        	        :
			:
		    ﾒﾝﾊﾞn:型;

	型名は大文字で構成し、'_'や数字がついてもかまいませんが、小文字は使え
	ません。逆に、メンバ名は小文字がなければ大文字はつかえません。
	構造体のなかでは配列は宣言できますが、構造体は宣言できません。

	ﾒﾝﾊﾞ名は構造体ごとに他の名前とは別の空間に登録しますので、他の構造体
	のﾒﾝﾊﾞ名と名前が衝突することはありません。

	structdefの次は'型名'であって、Ｃ でいうとこのTAG名でないのできおつけ
	てください。C なら typedef struct {...} 型名;とするところです。


	また、つぎのように, 
		structdef STRUCTYPE
		    memb1:BYTE[10],
		    memb2:WORD,
		    ++
		    memb3:WORD,
		    memb4:BYTE,
		    --
		    memb5:DWORD,
		　　--
		    memb6:BYTE[1],
		    memb7:BYTE[2],
		　　++
		    memb8:WORD;

	のように'++'でくぎると、次の'--'でくぎられたものが、'++'の位置のもの
	に重なるように配置されます。この例では
	+0	+1 	+2	+3	+4	+6	+7	+8	+9
	memb1   memb2	--	memb3	--	memb4		memb8	--
				memb5	--	--	--
				memb6	memb7	--
	というふうに配置されます。


      * 構造体変数

	構造体型で宣言された変数が構造体変数になります。
	構造体のメンバは
		構造体変数名.メンバ名
	としてアクセスします。
	例)
		StructVar.memb

	メンバの先頭よりの相対値(定数)は、
		構造体型名.メンバ名
	とすればえられます。
	例)
		STRUCTYPE.memb
		ax = STRUCTYPE.memb;
		ax = [bp+si+STRUCTYPE.memb];


　　　* 構造体変数のキャスト
	以下のように()をもちいて、まず変数の型を指定する構造体に変更
	したのち、そのメンバにアクセスします。
	例)
		(STRUCTYPE [...]).memb
		(STRUCTYPE Var).memb
		(STRUCTYPE cs.bx.di[0]).memb
		(STRUCTYPE ds.bx.si.Var).memb
		(STRUCTYPE cs.bx.di[20]).memb


  # 変数宣言
　	宣言子は、var,far var,static,auto,cvar の5種類があります。

	宣言子  変数名:型［= 初期値］｛,変数名:型［= 初期値］｝;

	また、near,global を宣言子の前につけてることもあります。

　	auto 以外の宣言子は, 手続き内で宣言すれば手続きないで、ﾓｼﾞｭｰﾙ内で
	near,globalをつけずに宣言すればﾓｼﾞｭｰﾙ内で、nearをつければ、ｸﾞﾙｰﾌﾟ
	内で、globalをつければ、ﾌﾟﾛｸﾞﾗﾑ全体で、使用することができます。
	near,globalは手続き内の変数にはつけられません。

　　  * var
	var    変数名:型 ｛,変数名:型｝;
	var    変数名 = 初期値;
	var    変数名:型 = 初期値;

      	実体をデータ部(基本的にdsｴﾘｱ)に配置するグローバル変数を宣言します。
	定数による初期化が可能です。
	RB,RIといっしょに型情報のあるまま指定するのは不可能です。

　　  * far var
	far var 変数名:型 ;

      	実体をfarﾋｰﾌﾟにとるグローバル変数を定義します。おもに、大きな配列を
	とりたいときに指定します。定数による初期化が可能です。
	far ﾎﾟｲﾝﾀでアクセスしなければいけなせん。
	RB,RIといっしょに型情報のあるまま指定するのは不可能です。

　　　* static
	static 変数名 = 初期値;
	static 変数名:型 = 初期値;

      	コード部(基本的にcsｴﾘｱ)に配置され（建前上）書き換え不可能な変数を宣言
	します。当然、C のstatic とは別ものです。
　　	ふつうのアセンブラのdb,dw 疑似命令に相当します。
	必ず初期化されないといけません。

　　	宣言されたそのばにコードを展開しますので、プログラムの途中におくばあい
	はあやまって実行されないよう気をつけてください。


　　  * cvar	// 仮称
	cvar   変数名:型 ｛,変数名:型｝;
　　　	実体のない変数ラベルの必要なときや、I/Oなどの絶対番地を変数としてｱｸｾｽ
　　	したいときにに宣言します。

	cvar (初期値)  変数名:型 ｛,変数名:型｝;
    	のように宣言し、初期値より名前の値を配置していきます。
	初期値がなければ０が指定されたことになります。

	所期値があれば、var変数とどうようにあつかわれ、RB,RIとともに型情報の
	あるまま指定するのは不可能です。

	所期値がないときは、var変数のようにあつかえず、かならずRBやRI,または
	var変数とともに指定してください。
		RB.RI.CVar
		Var.CVar
　　　	型名のいらない構造体みたいなもので、そのかわりメンバ名が他の名前と同じ
　　	空間に定義されたもの、ともいえます。


      * auto
	auto 変数名:型 ｛,変数名:型｝;
	実体をスタックにとるローカル変数を宣言します。
	bpによるアクセスを基本とします。
	手続き本体の宣言部で一度だけ行います。

	auto enter;
	実際にローカル変数のための領域を確保します。
	auto enter 変数名 = REG,変数名 = REG,REG,REG,...;
	として、レジスタをpushし、それに名前を付け、そののち、ﾛｰｶﾙ変数
	の領域を確保します。

	auto leave;
	auto enterで確保したﾛｰｶﾙ領域を開放し, pushしたﾚｼﾞｽﾀを復帰します。

	auto {
	    実行文;
		:
		:
	}
	{}内で、このﾌﾟﾛｸﾞﾗﾑが判別できる範囲でスタックに値をつむ動作をおこない、
	積んだまま{}ﾌﾞﾛｯｸをぬけるのならば、そのｽﾀｯｸをすてるように、sp += 定数;
	を生成する. gotoやifなどの分岐、 whileなどのﾙｰﾌﾟなどがこの{}内にある
	と当然うまくいかない。


　# gotoラベル
	手続き内のみのローカルなラベルと、モジュール内で有効なラベルがありま
	す。
	定義方法は、
		ラベル:    // 手続き内のみ
　　　　	ラベル::   // モジュール内で使用可能

  	モジュール内でなら手続きから他の手続きの途中に飛び込むという、まさに
	ｱｾﾝﾌﾞﾗなことができるわけです。あまり、するべきでありませんが。



  # 手続き
	実行文は手続き内にしかかけません。
	手続きはサブルーチンコールやジャンプで参照されます。

	手続きの宣言には次のものがあります。
	proc		    module内でしか使わない手続き
	procedure	    同一ｸﾞﾙｰﾌﾟに所属する他のmoduleから呼ばれる手続き
	common procedure    ｸﾞﾙｰﾌﾟ外からよばれる手続き

	near, far をつけない限り、proc, procedure は near でｱｾﾝﾌﾞﾙされ、
        common procedure は ｱｾﾝﾌﾞﾙﾓﾃﾞﾙに従います.

	実際の宣言は次のようになります。

	proc 手続き名 (<引数宣言>)
	    continue	ﾚｼﾞｽﾀ,ﾌﾗｸﾞ;
	    break	ﾚｼﾞｽﾀ,ﾌﾗｸﾞ;
	    return 	ﾚｼﾞｽﾀ,ﾌﾗｸﾞ,復帰引数名;
            return var  変数名;
	{
	    // 宣言部
	　　var	   <変数宣言>;
	    static <変数宣言>;
	    auto   <変数宣言>;
	　　auto enter <ﾚｼﾞｽﾀ>;

	    // プログラム部
	    (プログラム本体)
	    
	    auto leave;		// autoで確保した領域を削除.
	    return;		// 定義部のreturn 文で(ｻｲｽﾞ)が指定されていれば
				// それだけのこすように引数領域を削除する。
	}

	いうふうにします。
	ちゃんとreturn を書いてあげないと呼び出し側に帰らないので気をつけて
	ください。まず、ぼそります。

　　　<引数宣言>
	手続きに渡される値を並べます。
　　　　レジスタ名を並べると、そのレジスタで値がわたされるということを示し、
　　　　ここにならんでいないレジスタ(ax,bx,cx,dx,di,si)は直接参照できません。
　　　　var 宣言された引数は、手続き内でvar宣言された変数と同じで 大域に
　　　　配置され、スタックに積まれて値が渡されるのでなく、大域のメモリに
　　　　セットされて渡されます。
　　　　その他はｽﾀｯｸにつまれ、先に定義されたものがスタックの上にあるように
　　　　なります。基本的には引き数の排除は呼び出したほうがおこないます。

      <arg配列変数>
	ｽﾀｯｸにつまれる固定長の引数があれば、byte配列として arg[] が自動的に
　　　　定義されます。byte配列としてアクセスできますが、これは size(arg) と
　　　　して引き数のサイズを得るために用意しました。
        手続き外でも size(手続き名.arg) としてサイズを得られます。
　　　　可変長ではつかえません。

    　<手続きの宣言部>
	手続きは、基本的には、cs,ds,es,ss,di,si,bp,tﾌﾗｸﾞ,iﾌﾗｸﾞは保存されたと
	し、c,p,a,z,s,d,oフラグは破壊されたものとし、ax,bx,cx,dxは復帰値をもつ
	として、ｽﾀｯｸにつまれた引数は削除されずに、復帰します。
	 これらの使いかたを変更または明確にしたいときは、continue,break,return
	 宣言をつかって指定できます（指定されないものはデフォルトのままです）。

	指定できるレジスタ名は
		REG: ax,bx,cx,dx,al,ah,bl,bh,cl,ch,dl,dh,di,si,bp,ds,es
	です。sp,cs,ss,fl は指定できません。
	また、フラグ名は、
		FLG: d,s,z,c,i,o,a,p
	です。tフラグは指定できません。


	continue REG,FLGの列;
		復帰時に呼ばれたときと同じ値をもつ、ﾚｼﾞｽﾀ、ﾌﾗｸﾞを指定します。

	break   REG,FLGの列;
		復帰時に破壊されたまま返されるﾚｼﾞｽﾀ、ﾌﾗｸﾞを指定します。

	return  arg,REG,FLGの列;
		結果を返す、ﾚｼﾞｽﾀ、ﾌﾗｸﾞを指定します。
		
		argを指定するとｃでの呼び出しのように、引き数領域を削除せず
		残して復帰します。
		arg の指定がなければ引き数領域を手続き側で削除することになり
		ます。
		return の指定自体がなければ、ｽﾀｯｸにつまれた引数は削除されずに
		復帰します。
		引き数が可変長ならば指定できません。

		size(手続き名.arg)でこの値を参照できます。
		size(手続き名.arg)では当然可変長の手続きではエラーになります。

        return var VAR;
                これで指定された変数名は、引き数か手続き内で var 宣言された
　　　　　　　　変数を、手続き外で参照できるようにします。
　　　　　　　　手続き外からの参照は、ちょうど構造体のメンバと同じ扱いで、
　　　　　　　　構造体変数名の代わりに手続き名を使い、手続き名.変数名 として
　　　　　　　　参照します（ｽｺｰﾌﾟは構造体と同じです）。
　　　　　　　　参照はできますが代入はできません。


    <procdef 宣言>
	手続きは定義されてからでないと使えませんが、ばあいによっては定義する
	まえに呼び出したいばあいもあります。
	そういうばあいは、procdefを使って後で定義される手続きの引数や復帰値
	などを宣言してください。

	procdef 手続き名 (<引数宣言>) {
	    continue	<ﾚｼﾞｽﾀ,ﾌﾗｸﾞ>;
	    break	<ﾚｼﾞｽﾀ,ﾌﾗｸﾞ>;
	    return (復帰ｽﾀｯｸ) <ﾚｼﾞｽﾀ,ﾌﾗｸﾞ>;
	}
