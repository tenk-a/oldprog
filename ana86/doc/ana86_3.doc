#4  表記

#4.1 このドキュメントで使われる略記
	EA	実行ｱﾄﾞﾚｽ
	RG	ﾚｼﾞｽﾀ	R8,R16
	R8      8ﾋﾞｯﾄ長ﾚｼﾞｽﾀ	al,ah,cl,ch,dl,dh,bl,bh
	R16     16ﾋﾞｯﾄ長ﾚｼﾞｽﾀ	ax,cx,dx,bx,sp,bp,si,di
	AC	ｱｷｭｰﾑﾚｰﾀ･ﾚｼﾞｽﾀ	ah,ax
	RB	ﾍﾞｰｽ･ﾚｼﾞｽﾀ	bx,bp
	RI	ｲﾝﾃﾞｯｸｽ･ﾚｼﾞｽﾀ	di,si
	SG	ｾｸﾞﾒﾝﾄ･ﾚｼﾞｽﾀ	cs,ds,ss,es
	M	ｱﾄﾞﾚｽの示す内容 1 or 2 ﾊﾞｲﾄ
	M8	ｱﾄﾞﾚｽの示す内容 1 ﾊﾞｲﾄ
	M16	ｱﾄﾞﾚｽの示す内容 2 ﾊﾞｲﾄ
	M32	ｱﾄﾞﾚｽの示す内容 4 ﾊﾞｲﾄ
	I	即値(定数値) 1 or 2 ﾊﾞｲﾄ
	I8	即値(定数値) 1ﾊﾞｲﾄ
	I16	即値(定数値) 2ﾊﾞｲﾄ
	D	ﾃﾞｨｽﾌﾟﾚｲｽﾒﾝﾄ(定数値) 8 or 16 ﾋﾞｯﾄ
	D8	ﾃﾞｨｽﾌﾟﾚｲｽﾒﾝﾄ(定数値) 8ﾋﾞｯﾄ
	D16	ﾃﾞｨｽﾌﾟﾚｲｽﾒﾝﾄ(定数値) 16ﾋﾞｯﾄ
	PORT8	I/O ﾎﾟｰﾄ番号(0-255)
	ADDR	ｱﾄﾞﾚｽ

        LBL	型情報をもたない名前(gotoﾗﾍﾞﾙ等)
	Var	変数:型情報をもつ名前
	Ary	配列変数の名前


#4.2 レジスタ
    以下のレジスタがあります。小文字でしか指定できないことをのぞけば、名前の
  変更はおこなっていません。ただし、ﾌﾗｸﾞ･ﾚｼﾞｽﾀの下位ﾊﾞｲﾄをfl としました。

	R16 R8 R8	DEF.SEG
        ax  ah al		アキュームレータ
        bx  bh bl	ds	ベース
        cx  ch cl		カウンタ
        dx  dh dl		補助アキュームレータ
        sp		ss	スタック・ポインタ
        bp		ss	ベース・ポインタ
        si		ds	ソース・インデックス
        di		ds(es)	ディスティネーション・インデックス

        cs			コード・セグメント
        ds			データ・セグメント
        ss			スタック・セグメント
        es			エクストラ・セグメント

        ip		cs	インストラクション・ポインタ
       (fx)     fl		フラグ


	間接アドレス指定での セグメント オーバーライド 一覧
        ﾚｼﾞｽﾀ   def.seg     変更
        ip      cs          -
        sp      ss          -
        bp      ss          ds,es,cs
        bx      ds          ss,es,cs
        si      ds          ss,es,cs
        di      ds          ss,es,cs
                es          -


#4.3 ニーモニック
	命令.w  ｵﾍﾟﾗﾝﾄﾞのｻｲｽﾞが確定しないときに強制的にWORDにする

	命令	ｵﾍﾟﾗﾝﾄﾞ		ｲﾝﾃﾙ表記	式表現
      * @2の内容を@1にｺﾋﾟｰする
	ld	@1,@2		mov		@1 = @2;
                RG,RG
                RG,M
                M,RG
                RG,I
                M,I
                SG,R16
                SG,M16
                R16,SG
                M16,SG
		SG,SG		push @1;pop @2	SG = SG;
                ds:R16,M32      lds		ds:R16 = M32;
                es:R16,M32      les		es:R16 = M32;
                ah,fl           lahf		ah = fl;
                fl,ah           sahf		fl = ah;
        	al,[bx+al]      xlat		al = [bx + al];

      * MのｱﾄﾞﾚｽをR16にいれる
        (lea)	R16,&M		lea		R16 = &M;

      * @2の最上位ﾋﾞｯﾄが0なら@1を0に、1なら@1を~0にする
	sex	@1,@2
        	ah,al           cbw
                dx,ax           cwd

      * @1と@2の中身を入れ替える(ﾋﾞｯﾄ長をそろえること)
	xchg	@1,@2
        	RG,RG
                RG,M
                M,RG

      * @1と@2で二項演算し, 結果を@1に格納する
	add	@1,@2		add		@1+=@2;
	adc	@1,@2		adc		<無>
	sub	@1,@2		sub		@1-=@2;
	sbb	@1,@2		sbb		<無>
	cmp	@1,@2		cmp		(@1==@2)
	and	@1,@2		and		@1&=@2;
	or	@1,@2		or		@1|=@2;
	xor	@1,@2		xor		@1^=@2;
	btst	@1,@2		test		(@1&@2)
        	RG,RG
        	RG,M
        	M,RG
        	AC,I
        	RG,I
        	M,I


      * 掛算
        mul	al,R8		    		ax = al * R8;
        	al,M8				ax = al * M8;
                ax,R16				dx:ax = ax * R16;
                ax,M16				dx:ax = ax * M16;

        imul    al,R8		    		ax = al .*. R8;
        	al,M8				ax = al .*. M8;
                ax,R16				dx:ax = ax .*. R16;
                ax,M16				dx:ax = ax .*. M16;
	     // 186からの追加
	 	R1,R2,I		imul R1,R2,I	R1 = R2 .*. I;
		RG,M,I		imul RG,M,I	RG = M  .*. I;
      * 割算
        div	ax,R8				al = ax / R8;   ah = ax % R8;
        	ax,M8				al = ax / M8;   ah = ax % M8;
                dx:ax,R16			ax=dx:ax / R16; dx=dx:ax % R16;
                dx:ax,M16			ax=dx:ax / M16; dx=dx:ax % M16;
        idiv	ax,R8				al = ax./.R8;   ah = ax.%.R8;
        	ax,M8				al = ax./.M8;   ah = ax.%.M8;
                dx:ax,R16			ax=dx:ax./.R16; dx=dx:ax.%.R16;
                dx:ax,M16			ax=dx:ax./.M16; dx=dx:ax.%.M16;


      * not:1の補数をとる. neg:2の補数をとる
	not	@1				not(@1);
	neg	@1				neg(@1);
        	RG
        	M

      * ｲﾝｸﾘﾒﾝﾄ,ﾃﾞｨｸﾘﾒﾝﾄ
	inc	@1				++ @1;
	dec	@1				-- @1;
		R16
		R8
		M

      * ｼﾌﾄ･ﾛｰﾃｲﾄ
        shl	@1,@2				@1 <<= @2;
        shr	@1,@2				@1 >>= @2;
        sar	@1,@2				@1 .>>=. @2;
        rol     @1,@2				rol(@1,@2);
        ror     @1,@2				ror(@1,@2);
        rcl     @1,@2		rcl		(無)
        rcr     @1,@2		rcr		(無)
		RG,1
		RG,I				// 186以降. 86では合成.
		RG,cl
		M,1
		M,I				// 186以降. 86では合成.
		M,cl


	* フラグ関係(c,d,iフラグのon/off, cﾌﾗｸﾞの反転)
        setf    c               stc
                d               std		rep down;
                i               sti
        clrf    c               clc
                d               cld		rep up;
                i               cli
        notf    c               cmc

	* パック演算
        aaadd   		aaa
        aasub   		aas
        aamul   		aam
        aadiv   		aad
        daadd   		daa
        dasub   		das


	* ｽﾄﾘﾝｸﾞ命令
	repup 			cld
	repdown			std
	repcpy   al,si,1 	lods al
	repcpy   ax,si,cx	rep lods ax
	repcpy   es:di,al,1	stos al
	repcpy   es:di,ax,cx	rep stos ax
	repcpy   es:di,si,1	movsb
	repcpy.w es:di,si,cx	rep movsw
	repcmp   es:di,ah,1	scas ah
	repcmp   es:di,si,1	cmpsb
	repcmp.w es:di,si,1	cmpsw
	repequ   es:di,ah,cx	repe  scas ah
	repneq   es:di,ax,cx	repne scas ax
	repequ   es:di,si,cx	repe  cmpsb
	repequ.w es:di,si,cx	repe  cmpsw
	repneq   es:di,si,cx	repne cmpsb
	repneq.w es:di,si,cx	repne cmpsw

     // 186以降のみ
	repin    es:di,dx,1	ins
	repin    es:di,dx,cx	rep ins
	repout   dx,si,1	outs
	repout   dx,si,cx	rep outs


	* I/Oｱｸｾｽ
        in      AC,PORT8
                AC,dx
        out     PORT8,AC
                dx,AC


	* スタック 操作命令
        push    RG
                SG
                M
                fl		pushf
        pop     RG
                SG
                M
                fl		popf
     // 186以降
	push  I			push	I
	pusha ax,cx,bx,dx,si,di	pusha
	popa  di,si,dx,bx,cx,ax	popa
	enter			enter
	leave			leave


	* ジャンプ関係
        nop

        (ret)						return;
	retn
	retn	I
	retf
	retf	I

        call	@1
	jmp	@1
		D
        	ADDR
                RG
                M16
		M32

	go	   LBL		jmp D		// 強制ロング   go.w LBL
        go (>)	   LBL       	ja/jnbe		//		go.w (..) LBL
        go (>=)    LBL         	jae/jnb/
        go (c==0)  LBL         	jnc
        go (<)     LBL         	jb/jnae/
        go (c==1)  LBL         	jc
        go (<=)    LBL         	jbe/jna
        go (==)    LBL         	je/
        go (z==1)  LBL         	jz
        go (.>.)   LBL         	jg/jnle
        go (.>=.)  LBL         	jge/jnl
        go (.<.)   LBL         	jl/jnge
        go (.<=.)  LBL         	jle/jng
        go (!=)    LBL         	jne/
        go (z==0)  LBL         	jnz
        go (o==0)  LBL         	jno
        go (p==0)  LBL         	jnp/jpo
        go (s==0)  LBL         	jns
        go (o==1)  LBL         	jo
        go (p==1)  LBL         	jp/jpe
        go (s==1)  LBL         	js

        go (cx==0) LBL         	jcxz
        go (--cx)  LBL		loop
	go (--cx||==) LBL	loope/loopz
	go (--cx||!=) LBL	loopne/loopnz
        go (cx!=0) LBL	 	(jcxz)


	* 割り込み関係
        int    I
        into
        iret
        wait
        lock
        esc
        hlt


#4.4 ｺﾝﾊﾟｲﾗ表現

	* ax,bx,cx,dx を使用したコンパイル式
	変数 := 式;
	RG := 式;
	dx:ax := 式;

	{ }  　ショート範囲の複文
	（L{ } ロング範囲の複文　）	// 廃案！

	* 制御文
	if (比較式)	// ロングJMPにするには, if.w (条件) ... のようにする
		文;
	else		// else.w
		文;

	ifn (比較式)	// ifn.w (..) ...
		文;
	else
		文;
			// if,ifn では比較式のかわりに、(go比較)が使える


	while (比較式)	// while.w (..) ..
		文;

	do {		// do.w {...
		文;
	} while (比較式);

	until (比較式)	// until.w (..) ..
		文;

	do {
		文;
	} until (比較式);

        switch (RG|変数) {
	case 定数式:文;		// case.w ..: ...;
	default:文;		// default.w:
	}

        switch (RG|変数) (go比較) {	// switch (ax) (.>=.) {
	case 定数式:文;
	case 定数式:文;
	default:文;
	}

	rep switch (es:di,ax,cx) {
	case 定数式:文;
	case 定数式:文;
	default:文;
	}


	* 比較式:
		==,!=,>,<,>=,<=,.>.,.<.,.>=.,.<=. :比較子
	
		cmp
		@1 比較 @2

		dec,inc
		--@1 == 0 , ++@1 != 0

		sub,add,or,xor,and,shr,shl,sar,btst
			-=,+=,|=,^=,&=,<<=,>>=,.>>=,&:演算
		(@1 演算 @2)		//(..) == 0 のとき
		(@1 演算 @2) 比較 0

		比較式1 && 比較式2
		比較式1 || 比較式2

	    cx-reg 関係
		(--cx)
		(cx == 0)
		(cx != 0)
		(--cx || @1 == @2)
		(--cx || (@1 演算 @2) == 0)
		(--cx || (@1 演算 @2) != 0)


	* loop関係
	whileであらわされるが、loop命令を意識したいのと、whileで実装すんのが
	めんどくさそうなので、while文とはべつにloop文を用意しました。
	（whileでloop命令になりません）
	loop (--cx)			//jmp,loop
		文;

	loop (--cx||zf比較)		//jmp,loope|loopeq
		文;

	do {				//loop
		文;
	} loop (--cx);

	do {				//loope|loopne
		文;
	} loop (--cx||zf比較);


　　　* ストリング命令
	ストリング命令をwhileで表現するとうまくかけるが、ストリング命令を
	意識しにくいし、タイプがめんどくさいし、なにより、実装するのが、
	めんどくさそうなので、実装してません。
	まあ、こういう動作をしてるってことで。
	while (cx--)				// rep down cpy es:di,al,cx;
		BYTE [es:di--] = al;
	while (cx--)				// rep up cpy es:di,si,cx;
		WORD [es:di++] = [si++];
	while (cx-- && AC != [es:di++])		// rep up neq es:di,ac,cx;
		;
	while (cx-- && BYTE [di--] == [si--])	// rep down equ es:di,si,cx;
		;



	* 式形式でﾆｰﾓﾆｯｸと違うｺｰﾄﾞを生成するばあい
	RG = 0;		xor RG,RG
	(RG == 0)	or  RG,RG
	++ RG;		inc RG
	-- RG;		dec RG
	RG  += 1;	inc RG
	RG  -= 1;	dec RG
	R16 += 2;	inc R16;inc R16
	R16 -= 2;	dec R16;dec R16


	* R1:R2 疑似32ﾋﾞｯﾄ･ﾚｼﾞｽﾀ演算
	dx:ax = 0;		clr dx;clr ax;
	dx:ax = I16;		ld  ax,I16;clr dx;
	dx:ax = I16*0x10000;	clr ax;ld dx,I16;
	dx:ax = I32;		ld  ax,I16;ld dx,I16;
	dx:ax += I16;		add ax,I16;adc dx,0;
	dx:ax -= I32;		sub ax,I16;sbb dx,I16;
	not dx:ax;		not ax;not dx;
	neg dx:ax;		neg dx;neg ax;jc J1;dec dx;J1:

