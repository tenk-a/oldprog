
		８０８６アセンブラ・プリプロセッサ

		    ａｎａ８６(L1) ver. 0.17
			   （穴八六）

		  −−−−文法まにゅある−−−−




０．  はじめに


      このプログラムは独自表記のアセンブラ・ソースをＭＳＤＯＳの実質
    上の標準アセンブラ言語であるＭＡＳＭのソースに変換するものです。

      ａｎａはＣ言語とアセンブラのあいのこのような言語です。アセンブ
    ラ言語の命令はたいてい

	    mov ax,dx
	    add cx,5
	    inc si

    というような表現を用いますが、ａｎａでは

	    ax = dx
	    cx += 5
	    ++si

    のようにＣ言語と同じような式表現をします。
      もっともＣ言語に似ているのは式（演算子、数値）表現とおおざっぱ
    な考え方(^_^?)だけでその他の文法は別のものになっています。変数に
    対する演算や関数などは高級言語のようにはいかず、せこせこレジスタ
    を用いて書いてやらないといけませんが、 if 命令やループ命令、手続
    き呼び出しなどはそれらしいものになっており、変数の型に構造体や配
    列を用いたりできます。手続きはＣの関数として用いることを意識した
    引き数が宣言できます。

      なお、８０８６の命令は知っているものとし、MASM系アセンブラ、そ
    れにＣ言語についても（ある程度）知っているものとします（って、ぼ
    くのわかってる（つもりの）範囲ですが^^;）。

      えと。最初に謝っておきます(^^;
      文章ヘタです。説明不足です。言葉不正確です。... よくしたいとは
    思っていますが^^;

      正直いって、このマニュアルを見ただけでは anaのプログラムがどん
    なものかは伝わらないでせう。まず、ana でかかれたプログラムのソー
    スを眺めてください（ばっちいのでよいサンプルにはならない...^^;）

      あっと、それから、整数のみで、実数はサポートしていません。




１． とりあえず、ソースの感じ

      正確な説明は後回しにしてまず、ソース・ファイルが、どんな感じに
    なるか、書いてみます。

	module モジュール名

	    import モジュール名 //import するモジュール（ファイル）の指定

	    const 定数名 = 値,..	//定数ラベルの宣言

	    var  変数名:型,...  	//_DATAセグメントに配置する変数の宣言

	    cvar 変数名:型,...  	//_CODEセグメントに配置する変数の宣言

	    proc 手続き名(引数宣言)	//手続き宣言
	    enter
		ローカル変数・定数宣言

		実際の命令（手続き内でしかコードは書けない）
		（ax = 0 とか dx += 4
		  if条件分岐や loop命令
		  手続き呼びだし等）
		return
	    endproc

	endmodule

	import,const,var,proc、なんとなく想像つきますよね(^^;)
      cvarも。これら以外にも宣言はありますが、ま、とりあえず、どんな
      ものかの例えですから。


      それから、ana のソースを masm のソースに変換することを、コンパ
    イルする、ということにします。実際コンパイラみたいなもんだし:-)
    それに、生成されたソースをアセンブルするのと区別するためにも。




２．文、コメント、名前etc


２．１  文

      １つの文は基本的には改行で終了します。
      ただし、手続き内の命令に関しては、';' で区切ることにより複数の
    命令を１行に書くことができます（あくまで、手続き内だけです）。
      １文を複数行にしたいばあいは、Ｃの行連結の'\改行コード' を用い
    ます。

      そのた、いくつか例外的な扱いがあります... 例外は関係のある命令
    のところに書きます。
    （実は、変数宣言や手続きのパラメータをコンマで区切って並べるとき、
    コンマの後ろに現れる改行は空白として扱われます。が、廃止するつも
    りなので使うのはよしませう。）



２．２  コメント

      コメントは空白扱いで、Ｃと同じように空白のおけるところならどこ
    にもおける/*...*/ と、行の後に改行までを範囲とする//が使えます。
    /* */ はもちろん複数行にわたってもかまいません。

      あと、# が // と同じ機能をしますが、 これは ＬＳＩ―Ｃ試食版付
    属のＣＰＰを利用する目的で用意したのでコメントに使うのは控えてく
    ださい。

      注意：// でコメントにした行の改行の直前に \ があるときの動作は
	    未定ですので、そのような指定をしないでください。



２．３  名前, ラベル

      名前に使える文字は、'A'〜'Z','a'〜'z','_','0'〜'9'で、名前の始
    めには数字は使えません。先頭の２４文字ほどを認識しますが長すぎる
    分は無視します。
      ただ、グローバルな名前は、ターゲットのアセンブラが大文字小文字
    を区別しないばあいとか、ターゲットのアセンブラでの予約語だったり
    すると不幸ですので気をつけましょう。

      スコープがかさなる部分での名前の衝突は許されません。グローバル
    で使われている名前をローカル（手続き内）名に使用することはできま
    せん。
      もっとも、名前空間が異なればもちろん大丈夫です。

    （実は全角も使えるかもしれません^_^...ただし全角記号は不可。また、
      グローバルな手続き名や変数名に使うとターゲットのアセンブラでエ
      ラーになるでせう...でも、ターゲットのアセンブラが対応していたら
      ...）



２．４  数値

      ２進数、４進数、８進数、１０進数、１６進数が表せます。

	  ２進数： 0b ではじまり、'0','1'で構成されたもの
	  ４進数： 0q ではじまり、'0'〜'3'で構成されたもの
	  ８進数： 0o ではじまり、'0'〜'7'で構成されたもの
	  10進数： '0'〜'9'で構成されたもの
	  16進数： 0xで始まり'0'〜'9'の数字と'a'-'f'で構成されたもの

      0b,0q,0o,0x は必ず小文字でないといけませんが、数字を表す英字の
    大文字小文字は区別しません。

      ' で文字を囲むことによりその文字のコードを値とする文字定数もあ
     ります。文字にはＣと同様のエスケープ文字をサポートしています。
     （'で囲める文字は 2バイト以内です）

      あと、定数値のオーバーフローをチェックしてませんが、そのことに
    依存しないでください。



２．５  文字列定数

      " で囲まれた文字列のことです。byte配列やword配列の初期値を設定
    するときに利用します。
      基本的にはＣと違い文字列の終わりに'\0'が付くことはありません。
    （例外があります。）
      隣接する文字列定数は１行内では一つにまとめられますが、行が分か
    れるばあいは結合させません。



２．６  エスケープ文字

      Ｃと同じようなエスケープ文字が使えます。
	\N	0x0d0a 改行			CRLF
	\n	0x0a   ニューライン		LF
	\r	0x0d   キャリッジ・リターン	CR
	\t	0x09   水平タブ 		HT
	\v	0x06   垂直タブ 		VT
	\b	0x08   後退			BS
	\f	0x0c   改項			FF
	\a	0x07   ベル			BEL
	\\	\      円記号(バックスラッシュ)
	\'	'      単一引用符
	\"	"      二重引用符
	\xHH	0xHH   HHは１６進数
	\0	0x00   NIL文字
	\e	0x1b   エスケープ		ESC

      '\'の次の文字は大文字小文字を区別します。'\'の次にこれら以外の
    ものがくるとエラーになります。
      \n が単なる LF であって CRLF でないので気をつけてください。 そ
    のかわり \N で CRLF となります。
       \xHH では１６進数文字でないものが現れるまでを範囲としますが、
    下４桁まで有効でオーバーフローはいまのところ手抜きでチェックして
    ません。２桁に納まれは１バイト、そうでなければ２バイトになります
    （Ｃとはルールが違います）。
      Ｃでの８進数による指定はサポートしていません。また１０進数での
    指定も無理ですが、0 を表す \0 は指定可能です。



２．７  記号

      ａｎａで使われる記号には以下のものがあります。

	//  /*  */  ;  :  @
	=  ==  !  !=  ~
	+  +=  ++  -  -=  --  *  */  /  %
	&  &=  &&  |  |=  ||  ^
	(  )  [  ]  {  }  "  '  \
	<  <=  <<  <<=  >  >=  >>  >>=
	.  ...  .>.  .>=.  .>>=  .<.  .<=.



２．８  予約語

      少なくとも、以下の予約語があります。
      これら以外にも実際には使われていなくても、とりあえず予約語にな
    っているものもあります。
      出力先のアセンブラの命令や、セグメント名も使うと不幸でせう。

    aaadd       aadiv       aamul       aasub       adc         af
    ah          al          assume      ax          b           begin
    bh          bl          block       bound       bp          bx
    byte        c_name      call        cdecl       cf          ch
    cl          com         common      const       cs          cvar
    cx          d           daadd       dasub       data        decl
    defined     df          dh          di          div         dl
    ds          dw          dword       dx          else        elsif
    endblock    enddata     endif       endloop     endmodule   endproc
    endstruct   enter       es          esc         even        exit
    far         fh          fi          fl          fx          go
    gosub       goto        hlt         idiv        if          iif
    import      in          intr        ip          iret        jmp
    leave       load        local       lock        loop        macro
    model       module      near        neg         next        nop
    not         nothing     org         orig        out         ovf
    page        para        pf          pop         popa        port
    private     proc        public      push        pusha       rcl
    rcr         rep         repe        repn        ret         retf
    return      rol         ror         sar         save        sbc
    seg_cs      seg_ds      seg_es      seg_ss      segment     sf
    shl         shr         si          sizeof      sp          ss
    stack       start       struct      tf          type        typeof
    var         w           wait        word        ww          zf

    TINY        SMALL       COMPACT     MEDIUM      LARGE	P86
    MODEL

  （実際には使われてないけど登録されているもの...
    before      break       extern      external    forword     of
    to          seg
	と、いいつつ、before,extern(al),forword は...）




３．  定数演算etc


３．１  定数ラベル

      定数ラベルは、const 命令で定義されたものと、@set命令で定義され
    たものがあります。が、利用にあたっての違いは、@set命令ならば値を
    変更可能で const は駄目ということです。
      const,@set の実際の宣言は後で示します。



３．２  定数演算

      定数値はすべて４バイトの符号付き整数で、定数演算もそれで行われ
    ます。

      定数演算に使える演算子を書出ます。
	 1. (式)  ! not  ~  -  size()  defined()  %
	 2. *  /  %
	 3. +  -
	 4. <<  >>
	 5. <  <=  >  >=
	 6. ==  !=
	 7. &
	 8. ^
	 9. |
	10. &&
	11. ||

    基本的にＣのものと同じです。演算順位は、上の方ほど高いです。
      また、それぞれの機能は以下のとうりです。

      1. (式)  ! not ~  -  size()  defined()
	(式)	優先順位の低い演算を先に計算させるときに使います。
	!値	値が０なら１、０以外なら０。
	not 値   ! に同じ
	~値	値の各ビットを反転。
	-値	符号反転。
	sizeof()  ()内に指定された型や変数のしめるバイト数。
		Ｃのsizeof()の変形。
	defined()  ()内の名前が定義/宣言されたものなら１、違えば０。
	%名前	名前がローカル変数や構造体.メンバ名 だったばあい、そ
		れらがもつオフセット値。
      2. *  /  %
	それぞれ掛算,割算,余算 です。
      3. +  -
	それぞれ足算 と 引算 です。
      4. <<  >>  （.>>）
	左シフト、右シフト、（算術右シフト）です。
	（算術右シフトはサポートしていないかも）
      5. <  <=  >  >=
      6. ==  !=
	比較演算子で、条件が成立すれば１、だめなら０。
      7. &
	ビットごとの論理積。
      8. ^
	ビットごとの排他的論理和。
      9. |
	ビットごとの論理和。
      10. &&
	両辺がともに０でなければ１、どちらかが０なら０。
      11. ||
	両辺のどちらかが０でなければ１、どちらとも０なら０。



３．３  コンパイル時定数、リンク時定数

      定数値にはａｎａでコンパイルするときに値が決定し、生成するソー
    スで定数値になるものと、手続き名などのラベルが交ざり、アセンブラ
    でアセンブルしたとき（実際にはリンカーでリンクするとき）に値が決
    定されるものがあります。
      const C1 = 100 のとき、C1 + 20 は前者ですが、var v1:b とでもし
    て v1 が変数名で %v1 + 20 （% は変数のオフセット値を得る命令で、
    masmでは offset v1 になる）は後者になります。
      後者はこのようなものなので、アセンブラ命令の即値を指定できるば
    あいにしか使えません。つまり、ana での条件コンパイル命令での条件
    では使えませんし、定数ラベルに代入することはできません。
      今のところａｎａではリンク時に値が決定するラベルは手続き名と変
    数のみしか使えません。
      なお、リンク時に値を決定するラベルの交ざった式は、とりあえず、
    masm の演算子に置き換えて生成するはずですが、 妖しいかもしれませ
    ん。





４．  アセンブリ命令（ニーモニック）

      とりあえず、アセンブラなんだから、なによりニーモニックがどんな
    もんか示すために、レジスタ名、フラグ名、ニーモニックの普通の8086
    アセンブラとの対応を先に紹介することにします。



４．１ レジスタ名

      以下のレジスタがあります。小文字でしか指定できないことを除けば、
    名前の変更はおこなっていません。
      ただし、フラグ・レジスタを fx としその下位８ビットを fl としま
    した。

	ax  ah al	アキュームレータ
	bx  bh bl	ベース
	cx  ch cl	カウンタ
	dx  dh dl	補助アキュームレータ
	sp		スタック・ポインタ
	bp		ベース・ポインタ
	si		ソース・インデックス
	di		ディスティネーション・インデックス

	cs		コード・セグメント
	ds		データ・セグメント
	ss		スタック・セグメント
	es		エクストラ・セグメント

	ip		インストラクション・ポインタ

	fx     fl	フラグ



４．２  ３２ビット合成レジスタ

      １６ビット・レジスタ２つをつないで３２ビットのレジスタとして
    えます。もちろん、使える用途は限られますが。
      組合せに指定できるレジスタは、ax,bx,cx,dx,si,di,ds,esで、dx.ax
    や es.di のように表します。
      このうち、ds,es は上位ワードとして、si,di は下位ワードとしてし
    か指定できません。また ds, es を含む合成レジスタは代入やpush,pop
    でしか指定できません。



４．３  フラグ名

      なるべく一般的な表現にしましたが、iフラグ(if) と oフラグ(of)は
    それぞれ、iif と ovf としました。

	cf		キャリ・フラグ
	pf		パリティ・フラグ
	af		補助キャリ・フラグ
	zf		ゼロ・フラグ
	sf		サイン・フラグ
	ovf		オーバーフロー・フラグ
	tf		トラップ・フラグ
	iif		インタラプト・イネーブル・フラグ
	df		ディレクション・フラグ



４．４  略記

      このドキュメント（とくに４．５の命令一覧）では以下の略記を用い
    ます。

	R	レジスタ
	Rb	８ビット長レジスタ    al,ah,cl,ch,dl,dh,bl,bh
	Rw	１６ビット長レジスタ  ax,cx,dx,bx,sp,bp,si,di
	Rbw	Rb,Rw
	Rd	３２ビット長合成レジスタ（ax,bx,cx,dx,si,diの組合）
	RS	セグメント・レジスタ  cs,ds,ss,es
	RSd	ds,es を上位ワードとする32ビット長合成レジスタ
	RA	アキュームレータ・レジスタ ax,ah
	Mb	1 バイトのメモリ
	Mw	２バイトのメモリ
	Md	４バイトのメモリ
	Ib	１バイトの即値（定数:ラベル可)
	Iw	２バイトの即値（定数:ラベル可)
	Id	４バイトの即値（定数:ラベル可)
	LBL	型情報をもたない名前(gotoﾗﾍﾞﾙ等)
	Ibw	Ib,Iw
	MRb	Rb,Mb
	MRw	Rw,Mw
	MRbw	MRb,MRw
	MRIb	Ib,Rb,Mb
	MRIw	Iw,Rw,Mw
	MRIbw	MRIb,MRIw
		:
		: （こんな感じで組み合わさったもの^^;）


      あと、MRw.l, MRw.h とか MRd.l, MRd.h とかあるばあいは、MRw.lな
    ら MRw の下位バイト, MRw.h なら上位バイト、MRd.l ならMRdの下位ワ
    ード（ 2バイト）、MRd.h なら上位ワードというふうになります。

      また、これら以外にもその場その場で略記が用いられるばあいがある
    かもしれません^^;



４．５  命令（ニーモニック）一覧

      とりあえず、ａｎａでの表記と、対応するmasm系アセンブラのニーモ
    ニックの一覧です。
      合成命令というのがありますが、それは後で説明します。

      それと、二項演算では当然メモリ同士の演算はできません。
      両辺が  MRbw や MRIbw となっているばあいは、両辺の型は一致しな
    ければなりません。  たとえば、 MRbw += MRIbw ならば、MRb += MRIb
    と MRw += MRIw ということになり、MRw += MRb は指定できません（実
    はチェックさぼってるのでエラーになるコードを吐き出す...^^;）。

      それから、３２ビット合成レジスタの合成命令の生成される命令が省
    略されているのは、めんどくさかったからです^^;.. 実際に生成して確
    かめてください:-)

    （長いので、おおざっぱに感じをつかんだらとばして次にいってくださ
      い。で、必要なときに見返してね、と）

  -----------------------------+-----------------------------------------------
	ａｎａ命令		ｲﾝﾃﾙ表記, または合成命令で生成される命令
  -----------------------------+-----------------------------------------------
  □  代入／コピー
	MRbw = MRIbw		mov MRbw,MRIbw
	MRw = RS		mov MRw,RS
	RS = MRw		mov RS,MRw
	ds.Rw = Md		lds Rw,Md
	es.Rw = Md		les Rw,Md
	Rw = &M 		lea Rw,M	    	(M:ﾒﾓﾘで、型は無視）
	Rw = RI + Ibw		lea Rw,[RI+Ibw]     	(RI:di,si)
	Rw = RB + Ibw		lea Rw,[RB+Ibw]     	(RB:bp,bx)
	Rw = RB + RI		lea Rw,[RB+RI]		(RI:di,si RB:bp,bx)
	Rw = RB + RI + Ibw	lea Rw,[RB+RI+Ibw]	(RI:di,si RB:bp,bx)
	al = b[bx+al]		xlat
	ah = fl 		lahf
	fl = ah 		sahf
      合成
	R = R			---	(左右が同じばあい消滅)
	Rbw = 0 		xor Rbw,Rbw
	Rw = MRb		Rw.l = MRb; Rw.h = 0
	RS1 = RS2		push RS2;pop RS1
	RS = Iw 		push Iw;pop RS			(186以降)
	MRw = fx		pushf;pop MRw
	fx = MRw		push MRw;popf
	fx = Iw 		push Iw;popf			(186以降)
	MRd = MRId		MRd.l = MRId.l; MRd.h = MRId.h	(片方がRSdも可)
	RSd1 = RSd2		RSw1.l = RSw2.l; RSw1.h = RSw2.h
	Rd = 0  		Rd.l = 0; Rd.h = 0
	Rd = Id (High==0)	Rd.h = 0; Rd.l = Id.l
	Rd = Id (Low==0)	Rd.l = 0; Rd.h = Id.h
	Rd = Id (High==Low)	Rd.l = Id.l; Rd.h = Rd.l
	Rd = MRb		Rd.l.l = MRb; Rd.l.h = 0; Rd.h = 0
	Rd = MRw		Rd.l = MRw; Rd.h = 0

  □  符号拡張コピー		(cbw,cwd)
	ax .=. al		cbw
	dx.ax .=. ax		cwd
      合成
	ax .=. MRIb		al = MRIb;cbw
	dx.ax .=. MRIw  	ax = MRIw;cwd
	dx.ax .=. al		cbw;cwd
	dx.ax .=. MRIb  	al = MRIb;cbw;cwd

  □  交換
	MRbw1 <=> MRbw2 	xchg MRbw1,MRbw2
      合成
	R <=> R 		---  （同じレジスタを指定したばあい）
	Rd1  <=> Rd2

  □  加算
	MRbw += MRIbw		add MRbw,MRIbw
      合成
	MRbw += 0		---
	MRbw += 1		inc MRbw
	MRbw += -1		dec MRbw
	Rw += 2 		inc Rw;inc Rw
	Rw += -2		dec Rw;dec Rw
	Rd += MRId

  □  減算
	MRbw -= MRIbw		sub MRbw,MRIbw
      合成
	MRbw -= 0		---
	MRbw -= 1		dec MRbw
	MRbw -= -1		inc MRbw
	Rw -= 2 		dec Rw;dec Rw
	Rw -= -2		inc Rw;inc Rw
	Rbw -= Rbw		Rbw = 0 (両辺が同じばあい)
	Rd -= MRId

  □  論理積
	MRbw &= MRIbw		and MRbw,MRIbw
      合成
	MRbw &= 0		MRbw = 0
	MRb  &= 0xff		---
	MRw  &= 0xff		MRw.h = 0
	MRw  &= 0xff00  	MRw.l = 0
	Rbw  &= Rbw		---
	Rd   &= MRId

  □  排他的論理和
	MRbw ^= MRIbw		xor MRbw,MRIbw
      合成
	Rd   ^= MRId

  □  論理和
	MRbw |= MRIbw		or  MRbw,MRIbw
      合成
	MRbw |= 0		---
	MRb  |= 0xff		MRb = 0xff
	MRw  |= 0xff		MRw.l = 0xff
	MRw  |= 0xff00  	MRw.h = 0xff
	MRw  |= 0xffff  	MRbw = 0xffff
	Rbw  |= Rbw		---
	Rd   |= MRId

  □  比較
	MRbw -  MRIbw		cmp MRbw,MRIbw
      合成
	Rbw - 0 		or  Rbw,Rbw

  □  ビット・テスト
	MRbw &  MRIbw		test MRbw,MRIbw

  □  MRbw = MRbw + MRIbw + cf
	adc MRbw,MRIbw  	adc MRbw,MRIbw
      合成
	adc Rd,MRId

  □  MRbw = MRbw - MRIbw - cf
	sbc MRbw,MRIbw  	sbb MRbw,MRIbw
      合成
	sbc Rd,MRId

  □  インクリメント
	++MRbw  		inc MRbw
      合成
	++MRd

  □  デクリメント
	--MRbw  		dec MRbw
      合成
	--MRd

  □  ビット反転
	com MRbw		not MRbw
      合成
	com MRd

  □  符号反転
	neg MRbw		neg MRbw
      合成
	neg MRd

  □  左シフト
	MRbw <<= 1		shl MRbw,1
	MRbw <<= cl		shl MRbw,cl
	MRbw <<= Ib (Ib > 0)	shl MRbw,Ib			(8086ﾓｰﾄﾞ不可)
	MRbw <<= Ib (Ib < 0)	Ib2 = -Ib にして、shr MRbw,Ib2
      合成
	MRbw <<= 0		---
	Rbw <<= Ib		その回数分、shl Rbw,1を生成	(8086ﾓｰﾄﾞのみ)
	Rw <<= 8		Rw.h = Rw.l; Rw.l = 0		(8086ﾓｰﾄﾞのみ)
	Rw <<= Ib (9〜15)	Rw <<= 8; Rw.h <<= Ib-8 	(8086ﾓｰﾄﾞのみ)
	Rw <<= Ib (16〜)	Rw = 0
	Rd <<= Ib

  □  右シフト
	MRbw >>= 1		shr MRbw,1
	MRbw >>= cl		shr MRbw,cl
	MRbw >>= Ib (Ib > 0)	shr MRbw,Ib			(8086ﾓｰﾄﾞ不可)
	MRbw >>= Ib (Ib < 0)	Ib2 = -Ib にして、shl MRbw,Ib2
      合成
	MRbw >>= 0		---
	Rb >>= Ibw		その回数分、shr Rbw,1を生成	(8086ﾓｰﾄﾞのみ)
	Rw >>= 8		Rw.l = Rw.h; Rw.h = 0		(8086ﾓｰﾄﾞのみ)
	Rw >>= Ib (9〜15)	Rw >>= 8; Rw.l >>= Ib-8 	(8086ﾓｰﾄﾞのみ)
	Rw >>= Ib (16〜)	Rw = 0
	Rd >>= Ib

  □  算術右シフト
	MRbw .>>= 1		sar MRbw,1
	MRbw .>>= cl		sar MRbw,cl
	MRbw .>>= Ib (Ib > 0)	sar MRbw,Ib			(8086ﾓｰﾄﾞ不可)
	MRbw .>>= Ib (Ib < 0)	Ib2 = -Ib にして、shl MRbw,Ib2
      合成
	MRbw .>>= 0		---
	Rbw .>>= Ib (1〜7)	その回数分、sar Rbw,1を生成	(8086ﾓｰﾄﾞのみ)
	Rb .>>= Ib (8〜)	Rbw .>>= 7
	Rw .>>= Ib (8〜14)	Rw.l .>>= 8;Rw .>>= Ib-8	(8086ﾓｰﾄﾞのみ)
	Rw .>>= Ib (15〜)	Rw.l .>>= 7;Rw.h = Rw.l 	(8086ﾓｰﾄﾞのみ)
	Rd .>>= Ib

  □  左ローテート
	rol MRbw,1		rol MRbw,1
	rol MRbw,cl		rol MRbw,cl
	rol MRbw,Ib  (Ib > 0)	rol MRbw,Ib			(8086ﾓｰﾄﾞ不可)
	rol MRbw,Ib  (Ib < 0)	Ib2 = -Ib にして、ror MRbw,Ib2
      合成
	rol MRbw,0		---
	rol MRbw,Ib		その回数分、rol Rbw,1を生成	(8086ﾓｰﾄﾞのみ)
	rol Rb,Ib  (Ib:5〜7)	Ib2 = 8-Ib にして, ror MRb,Ib2
	rol Rw,Ib  (Ib:5〜7,12〜15)  Ib2 = 16-Ib にして, ror MRw,Ib2
	rol Rw,8		Rw.h <=> Rw.l
	rol Rw,Ib  (Ib:9〜11)	rol(Rw,8); rol(Rw,Ib-8) 	(8086ﾓｰﾄﾞのみ)
	rol MRb,Ib (Ib:8〜)	Ibを 8 で割った余りにして行う
	rol MRw,Ib (Ib:16〜)	Ibを16 で割った余りにして行う
	rol Rd,Ib

  □  右ローテート
	ror MRbw,1		ror MRbw,1
	ror MRbw,cl		ror MRbw,cl
	ror MRbw,Ib (Ib > 0)	ror MRbw,Ib			(8086ﾓｰﾄﾞ不可)
	ror MRbw,Ib (Ib < 0)	Ib2 = -Ib にして、rol MRbw,Ib2
      合成
	ror MRbw,0		---
	ror Rbw,Ib		その回数分、ror Rbw,1を生成	(8086ﾓｰﾄﾞのみ)
	ror Rb,Ib (Ib:5〜7)	Ib2 = 8-Ib にして, rol MRb,Ib2
	ror Rw,Ib (Ib:5〜7,12〜15)  Ib2 = 16-Ib にして, rol MRw,Ib2
	ror Rw,8		Rw.h <=> Rw.l
	ror Rw,Ib (Ib:9〜11)	ror Rw,8; ror Rw,Ib-8		(8086ﾓｰﾄﾞのみ)
	ror Rb,Ib (Ib:8〜)	Ibを8で割った余りにして行う
	ror Rw,Ib (Ib:16〜)	Ibを16で割った余りにして行う
	ror Rd,Ib

  □  cfを介した左ローテート
	rcl MRbw,1		rcl MRbw,1
	rcl MRbw,cl		rcl MRbw,cl

	rcl MRbw,Ib (Ib > 0)	rcl MRbw,Ib			(8086ﾓｰﾄﾞ不可)
	rcl MRbw,Ib (Ib < 0)	Ib2 = -Ib にして、rcr MRbw,Ib2 を行う
      合成
	rcl MRbw,0		---
	rcl Rbw,Ib		その回数分、rcl Rb,1を生成	(8086ﾓｰﾄﾞのみ)
	rcl Rb,Ib   (Ib:5〜8)	Ib2 = 9-Ib にして、rcr MRb,Ib2
	rcl Rw,Ib   (Ib:9〜16)  Ib2 = 17-Ib にして、rcr MRb,Ib2
	rcl Rb,Ib   (Ib:9〜)	Ib を 9で割った余りにして行う
	rcl Rw,Ib   (Ib:17〜)	Ib を17で割った余りにして行う
	rcl Rd,Ib

  □  cfを介した右ローテート
	rcr MRbw,1		rcr MRbw,1
	rcr MRbw,cl		rcr MRbw,cl
	rcr MRbw,Ib  (Ib > 0)	rcr MRbw,Ib			(8086ﾓｰﾄﾞ不可)
	rcr MRbw,Ib  (Ib < 0)	Ib2 = -Ib にして、rcl MRbw,Ib2 を行う
      合成
	rcr MRbw,0		---
	rcr Rbw,Ib		その回数分、rcr Rbw,1を生成	(8086ﾓｰﾄﾞのみ)
	rcr Rb,Ib   (Ib:5〜8)	Ib2 = 9-Ib にして、rcl MRb,Ib2
	rcr Rw,Ib   (Ib:9〜16)  Ib2 = 17-Ib にして、rcl MRb,Ib2
	rcr Rb,Ib   (Ib:9〜)	Ib を 9で割った余りにして行う
	rcr Rw,Ib   (Ib:17〜)	Ib を17で割った余りにして行う
	rcr Rd,Ib

  □  符号無掛算
	ax = al * MRb		mul MRb
	dx.ax = ax * MRw	mul MRw
      合成
	ax = al * Ib		ah = Ib;mul ah
	ax = MRb * MRIb 	ah = MRb; al =  MRIb; mul ah
	dx.ax = ax * Iw 	dx = Iw; mul dx
	dx.ax = MRw * MRIw	ax = MRw; dx =  MRIw; mul dx

  □  符号付掛算  (imul)
	ax = al .*. MRb 	imul MRb
	dx.ax = ax .*. MRw	imul MRw
	Rw = MRw .*. Iw 	imul Rw,MRIw,Iw 		(8086不可)
      合成
	ax = al .*. Ib  	ah = Ib;imul ah
	ax = MRb .*. MRIb	ah = MRb; al =  MRIb; imul ah
	dx.ax = ax .*. Iw	dx = Iw; imul dx
	dx.ax = MRw .*. MRIw	ax = MRw; dx =  MRIw; imul dx

  □  割算(余算)  (div,idiv)
	div ax,MRb		div  MRb
	div dx.ax,MRw		div  MRw
	idiv ax,MRb		idiv MRb
	idiv dx.ax,MRw  	idiv MRw

  □  cfフラグ関係
	cf = 1  		stc
	cf = 0  		clc
	com cf  		cmc

  □  パック演算
	aaadd			aaa
	aasub			aas
	aamul			aam
	aadiv			aad
	daadd			daa
	dasub			das

  □  I/Oポート・アクセス
	al = port(Ib)		in  al,Ib
	ax = port(Ib)		in  ax,Ib
	al = port(dx)		in  al,dx
	ax = port(dx)		in  ax,dx
	port(Ib) = al		out Ib,al
	port(Ib) = ax		out Ib,ax
	port(dx) = al		out dx,al
	port(dx) = ax		out dx,ax

  □  スタック操作命令
	push MRw		push MRw
	push RS 		push RS
	push fx 		pushf
	push Iw 		push Iw 			(8086は不可)
	pop  MRw		pop  MRw
	pop  RS 		pop  RS
	pop  fx 		popf
	pusha			pusha				(8086は不可)
	popa			popa				(8086は不可)
	enter Iw,Ib		enter Iw,Ib			(8086は不可)
	leave			leave				(8086は不可)
      合成
	pusha			push ax,cx,bx,dx,si,di  	(8086のみ)
	popa			pop  di,si,dx,bx,cx,ax  	(8086のみ)
	enter Iw,0		push bp;sub sp,Iw		(8086のみ)
	leave			mov sp,bp;pop bp		(8086のみ)
	push  MR1,MR2,...,MRn	push MRn; push MRn-1...MR1  (積む順番は右から)
	pop   MR1,MR2,...,MRn	pop  MR1; pop MR2...MRn     (戻す順番は左から)
	save			手続き入口専用のpush
	load			save に対応した pop

  □  割り込み関係
	intr.on  (iif = 1)	sti
	intr.off (iif = 0)	cli
	intr Ib 		int  Ib
	intr.ovf		into
	iret			iret
	wait			wait
	hlt			hlt
	esc  Ib,MR		esc  Ib,MR
	lock 命令		lock; 命令	(プレフィックス)

  □  セグメント・オーバーライド
	seg_cs			(seg cs)
	seg_ds			(seg ds)
	seg_es			(seg es)
	seg_ss			(seg ss)

  □  ストリング命令
	rep			rep
	repe			repe/repz
	repn			repne/repnz

	rep.inc (df = 0)	cld
	rep.dec (df = 1)	std

	rep.load al, si 	lodsb
	rep.load ax, si 	lodsw
	rep.load al, si, cx	rep lodsb
	rep.load ax, si, cx	rep lodsw

	rep.set   di, al	stosb
	rep.set.w di, ax	stosw
	rep.set   di, al, cx	rep stosb
	rep.set.w di, ax, cx	rep stosw

	rep.cpy   di,si 	movsb
	rep.cpy   di,si,cx	rep movsb
	rep.cpy.w di,si 	movsw
	rep.cpy.w di,si,cx	rep movsw

	repe.scan   di,al	scasb		※  もちろんrepeの代わりに
	repe.scan.w di,ax	scasw		    repn も使えます.
	repe.scan   di,al,cx	repe scasb
	repe.scan.w di,ax,cx	repe scasw

	repe.cmp   di,si	cmpsb
	repe.cmp   di,si,cx	repe cmpsb
	repe.cmp.w di,si	cmpsw
	repe.cmp.w di,si,cx	repe cmpsw

    (80186以降)
	rep.inp   di,dx 	insb
	rep.inp   di,dx,cx	rep insb
	rep.inp.w di,dx 	insw
	rep.inp.w di,dx,cx	rep insw

	rep.outp   dx,si	outsb
	rep.outp   dx,si,cx	rep outsb
	rep.outp.w dx,si	outsw
	rep.outp.w dx,si,cx	rep outsw

  □  ジャンプ関係
	nop			nop
	ret			retn
	ret	   Iw		retn Iw
	ret.d/retf		retf
	red.d/retf Iw		retf Iw
	jmp	   GLBL		jmp GLBL	※GLBLは手続き名などのグロー
	jmp	   MRw		jmp MRw 	  バルな行き先ラベルです
	jmp	   Md		jmp Md
	jmp.d	   Id		jmp Id
	call	   GLBL		call GLBL
	call	   MRw		call MRw
	call	   Md		call Md
	call.d     Id		call Id

	go	   LBL  	jmp LBL 	※LBL は手続き内のローカル
	gosub	   LBL  	call LBL	  な go の行き先ラベルです
    (条件分岐)
	go (>)     LBL  	ja/jnbe
	go (>=)    LBL  	jae/jnb/
	go (!cf)   LBL  	jnc
	go (<)     LBL  	jb/jnae/
	go (cf)    LBL  	jc
	go (<=)    LBL  	jbe/jna
	go (==)    LBL  	je/
	go (zf)    LBL  	jz
	go (.>.)   LBL  	jg/jnle
	go (.>=.)  LBL  	jge/jnl
	go (.<.)   LBL  	jl/jnge
	go (.<=.)  LBL  	jle/jng
	go (!=)    LBL  	jne/
	go (!zf)   LBL  	jnz
	go (!ovf)  LBL  	jno
	go (!pf)   LBL  	jnp/jpo
	go (!sf)   LBL  	jns
	go (ovf)   LBL  	jo
	go (pf)    LBL  	jp/jpe
	go (sf)    LBL  	js

	go (!cx)   LBL  	jcxz
	go (--cx)  LBL  	loop
	go (--cx&&zf)  LBL	loope/loopz
	go (--cx&&!zf) LBL	loopne/loopnz
	go (cx)    LBL  	(jcxz合成)



４．６  合成命令

      アセンブラでは基本的にニーモニックとマシン語は１対１に対応しま
    が、フラグ変化が無視できるときは mov ax,0 のかわりにサイズが小さ
    く速くなる xor ax,axとか、 add ax,1 のかわりに inc ax とか、フラ
    グ変化も同じで生成されるサイズの違いを無視できるときは cmp ax,0
    のかわりに test ax,ax とかがよく用いられます。
      そこで  ana では、基本的に式表現の演算では使用すると演算関係の
    フラグは不安定になるものとし（条件式中は別）、動作が同じならば速
    いほうがいいし小さいほうがいい、ということで、置き換えられるもの
    は置き換えることにしました。またその延長で、定数回シフトとかpush
    pop での複数指定とか３２ビット・レジスタの演算等の拡張命令も用意
    しました。

      もちろん、合成命令でなく、本来の命令を使いたいばあいもあるので
    そういうときは明示的に指定する必要があります。
      指定方法は、式（命令）の前に'orig'また'|' を付けてやります。
      式表現された命令に'|' を付けて元の命令を使いたいというのは、た
    いていは、その命令のフラグ変化を次の命令が利用するということです。
    たとえば、
	orig ax <<= 1
	adc bx,0
    や
	|ax - 5
	|go (.<.) JMIN
	go (.>.) JMAX
    というふうになります。フラグ変化を参照するだけの命令（このばあい
    adc(bx,0) や go(.>.) JMAX ）には付ける必要はありません。
      また、cf = 1 など、見てすぐわかるものは付ける必要ないでしょう。
      手続きで値をフラグで返すばあいもありますが、手続きは合成命令な
    ので'|'をつけてはいけません。あくまで合成命令になってしまう可能
    性のある命令を、合成命令にしないようにするためのものです。
      '|' を基本命令にない合成命令に指定すると、本来はエラーにしなき
    ゃいけないのですが、チェックさぼってエラーにならないばあいがある
    ので気をつけてください（ばあいによっては生成に影響をあたえるかも
    しれません）。




４．７  代入について

      せっかくＣの式に似せてるので、制限付きですが連続代入を行えます。

	MR1 = MR2 = MR3 = MRI

    のように指定できます。これは、右から順に、

	MR3 = MRI
	MR2 = MR3
	MR1 = MR2

    というふうに展開されます。
      MRI の部分は, セグメントや port() も指定できます（というか、そ
    れができるようにとサポートしたのですが）。
      一番右の代入'='のみ、代わりに .=. が指定できます。が、他の演算
    子（+= や <<= 等）は不可能です。
      もちろん、各代入は生成できるものでないといけません。メモリ同士
    の代入はエラーですし、port() や .=. は対になるレジスタが固定され
    てるので間違えないようにしませう。



４．８  シフト命令について

      sar や rol, rcr 等の式表現でない命令でも合成命令があるのは少々
    みっともないような気もしますが、できると便利なので行なうようにし
    ました。ま、手続きや、マクロ命令もあるので、どっちにしてもチョッ
    どみただけでは何が生成されるかわからんソースが出来てしまうので^^;



４．９  スタック操作命令について

      push, pop は複数のレジスタ、メモリを指定できます。
      push は 右（後）からスタックに積み、pop は左（前）から復活しま
    す。
      右から積むのは手続きの引数の仕様にあわせたからですが、手続きは
    Ｃを意識しているのでＣに合わせたともいえます。
      push/pop の引数は省略不可です。
      push したものをそのまま元のレジスタに復帰したいばあいは、push
    と同じレジスタを同じ順番で並べれば対応します。
      例) push dx,ax,ds
		:
		:
	  pop  dx,ax,ds

      なお、手続き入り口でのレジスタ退避のために save 命令およびそれ
    らを pop する return と load命令があります。これについては、手続
    きの説明をみてください。



４．１０  割り込み関係について

      lockはプレフィックスで、実際には '|'が必要で基本命令に対しての
    み指定できます。|lock b[si] = 0 とかいうふうになります。



４．１１  ストリング命令について

      rep,repe,repn はプレフィックスですが、モジュール名にみたてて、
    他の命令よりもより手続きっぽくしてあり、rep.loadの引数のal,ax以
    外の引数は手続きと同じように暗黙の代入がおこなわれます。
    （暗黙の代入... rep.load ax,&buf とかなら si=&buf;rep.load ax,si
      というふうになります。手続きのところで説明します）
      ただ、バグで、al,ax の部分では暗黙の代入は行なえません（もっと
    も rep.scan ではできなくて当然ですが... 実はこの処理の影響みたい
    です^^;）

      rep.cmp, rep.scan では実際には repe だけでなく repn も指定でき
    ます。

      di のしめすアドレスのセグメントは当然 es 固定ですが、si のセグ
    メントはデフォルトは ds で、セグメント・オーバーライドを行いたい
    場合は si のところで４バイトレジスタか ww() で指定してください。
    （rep.cpy di,ss.si とか rep.cmp.w di,ww(cs,&buf) など）
      ただし、セグメントオーバーライト・プレｆィックスとストリング命
    令のプレフィックスの２つのプレフィックスを指定したばあい、割り込
    み関係で問題がある（らしい）ので使うなら気をつけてください。

      repe.scan は al(ax) からdiのアドレスの内容を（仮に）引くことに
    なるので repe.scan al,di のほうがいいのかもしれませんが、di の位
    置を揃えたかったのでこっちにしました（実は当所 scas は di でなく
    si を用いると思い込んでいた、その名残です^^;）。repe.scan 後にそ
    のフラグ変化を利用して大小比較をすると少々みずらい気もしますが、
    そんなことは滅多にしないので、ま、いいや、と^^;。



４．１２  ジャンプ関係について

      go 文の条件で (cf) や (!cf) などのフラグを指定するばあいそれら
    のかわりに (cf == 1) や (cf == 0) のようにも書けます。

      go,goto,gosub 命令の行き先ラベルは手続き内でのみ有効なラベルで、
    jmp や call では指定できません。jmp や call では、手続き名が指定
    できます。
      このため、手続き外に直接条件分岐できないため無理に分かれていた
    手続きを一つにしたり、我慢して条件わけしたあと、jmp することにな
    り、ばあいによっては苦痛がともなうかもしれません。

      go, goto, gosub, jmp, call では, 命令.w でロング・ジャンプ指定、
    命令.b でショート・ジャンプ指定となり、jmp と call は, 命令.d で、
    far ジャンプ指定になります。指定のないときは、 go 以外は .w、go
    は .b となります。
      .b は強制ショート指定ですが、.w は強制ロングでなく出力先のアセ
    ンブラでは無指定なだけですので、後方参照のものは実際のオブジェク
    トではショートになるかもしれません（強制ロング指定はできません）。

      go.w(条件) はもちろん合成命令で、条件を逆にしたものと jmp を組
    合せたものになります（ただし go.w(--cx&&zf) , go.w(--cx&&!zf) は
    できません... が、go.w(--cx) や go.w(cx==0) は強引に生成するはず
    です^^）
      生成されるソースのジャンプ命令のショート／ロングを自動判別する
    ようなことはないので go はプログラムを組む人がエラーにならないよ
    う.w を指定する必要があります。
      もっとも、生成したソースをアセンブルするアセンブラが多パスでオ
    プティマイズしてくれるものだと話がかわってしまいますが(^^)
    （でも、明示的に.wを指定したほうが生成されるコードはよいものにな
      ると思います...場合にもよりますが...）

      jmp/callの定数指定は、farジャンプ/コールのみで、定数値か、ww()
    の２つの引数に即値を設定したものでないといけません。



４．１３  ３２ビット合成レジスタの演算命令

      ３２ビット合成レジスタを用いた命令は、

	ds.ax .=. ax  ds.Rw = Md  es.Rw = Md
	dx.ax = ax * Rw  div dx.ax, Rw

    の8086本来の命令以外に、

	=,+=,-=,&=,|=,^=,adc,sbc
	++,--,com,neg,>>=,<<=,.>>=,sar,ror,rol,rcr,rcl,

    があります。シフト命令以外の二項演算では、右辺が４バイト同士でな
    いといけません。

    当所は、４バイト同士以外にも、右辺が２バイト、１バイトでもいいよ
    うにしていましたが（上位は０にする）、ソースの変更等を行なってい
    る内（とくに手続きの暗黙の代入）に誤使用してしまうばあいが多く、
    それが farポインタへの代入だったりするとシステム領域の破壊につな
    がり危ないので禁止することにしました。
    ２バイトレジスタ・変数への１バイト型の代入も同様に誤使用してしま
    うので禁止しました。
    アセンブラでは、暗黙の型変換はやらないほうが無難ということでした。
    できるようにするなら、明示的に指定するようにするべき、と^^;。




５．  制御命令(if,loopなど)


      if や loop は 条件ジャンプ（go命令）を組合せて実現しています。
      これらの命令はひたすら楽をするためにあり、生成される命令は結構
    無駄が多く、特に elsif や else、多重ループ等が重なると、非常にま
    ぬけなことになります。気になるばあいは、条件ジャンプを自前で行っ
    たほうがいいでしょう。
      見た目の行き先ラベルを減らすのが目的でありますが、まったく無く
    そうなどとは考えないでください。とくに return 命令のこともあるの
    で、無残なソースを吐き出すことになります。
      ブロック内の<命令群>のサイズがショート・ジャンプでスキップでき
    なくなるばあいは、 命令.w（if.w とか else.w, loop.wなど）として、
    ロング・ジャンプに指定する必要があります。
      (条件)が、go の基本命令のものならば、命令の頭にorig,'|' を付け
    ることができます。



５．１  if 〜 elsif 〜 else 〜 fi

      （条件）により条件分岐します。

	if (条件1)
	    <命令群1>
	elsif (条件2)
	    <命令群2>
		:
		:
	elsif (条件n)
	    <命令群n>
	else
	    <命令群n+1>
	fi

      (条件)を上から調べていき、一致したところの<命令群>を実行します。
    条件が一致しないばあいはelseの<命令群>を実行します。

      elsif,else は当然省略できますが、fi は省略できません。

      elsif,else が現れるとその if ブロックをぬける jmp 命令が生成さ
    れますが、それを強制ショートにするようなことはしませんが、もし、
    elsif,else の直前が、条件無しの goや jmp,ret,return なら、わざわ
    ざ脱出用の jmp 命令は生成しないので少し安心してください。
      それでも、elsif,else や loop が隣接してついでに .w 指定だった
    りすると、生成されるコードを見ると人によっては切れてしまうかもし
    れません... ま、効果を考えればたいしたことないと思いますが。

      なお、fi の別名として endif があります。むしろ、こちらのほうが
    他の命令との兼ね合いから言っても正式なもののはずですが... まあ、
    好み...未練、意地です^^;（当所はend?? という形でなく、みな、逆綴
    りを採用していたのですが... 他はなかなか覚えにくいので。でも、fi
    だけは採用したい、と）




５．２  loop 〜 endloop

    ループ命令は、条件の有無、条件の位置により、３タイプあります。

    1)  無限ループをおこないます。

	loop			L$LBL:
	    <命令群>	==>		<命令群>
	endloop 		go L$LBL


    2)  (条件)が成立する間ループします。判定はループ内の命令実行後に
	行います。

	loop			L$LBL:
	    <命令群>	==>		<命令群>
	endloop (条件)  	go (条件) L$LBL

    3)  (条件)が成立する間ループします。判定はループ内の命令実行前に
	行います。みてのとうり 2) に jmp 命令を付け加えたものです。

	loop (条件)			goto L$LBL2
	    <命令群>	==>	L$LBL:
	endloop 			<命令群>
				L$LBL2: go (条件) L$LBL

      見てのとおり、可能ならば 3) のスタイルは用いず、2) になるよう
    に条件や初期値を設定したほうがいいでせう。

      あと、ループ制御命令として、Ｃの break,continueにあたる、exit,
    とnextというのがあり、多重ループ脱出用に、ブロック名の指定ができ
    ます。



５．３  block 〜 endblock

      ループしない loop 〜 endloop みたいなもので ブロックをつくるだ
    けです。 exit, next を利用するために用意しました。もちろん、ブロ
    ック名指定できます。 exit, next のためのジャンプ・ラベルを生成す
    るだけで、jmp 等命令は一切生成されません。

	block
	   :
	   :
	endblock

      ループ命令での next は若干効率がわるく、たとえ無条件ループでも
    一番下のendloopでの jmp 命令のとこにジャンプしてしまうので、その
    ことが気になるばあい、block〜endblockで範囲を限定して、next で
    blockのある位置に直接ジャンプするようにしてやろうというものです、
    もとは。
      ループ命令でもないのにループしてしまうのは気持ちわるい方もいる
    かもしれませんが、どうせ go 命令があるんだし、それよりかは限定し
    た使い方になるので、意味はあるんじゃないか、と^^?;



５．４  exit, next

      loop 〜 endloop, block 〜 endblock の間に置き、 条件が成立すれ
    ば、 exit は ループ脱出、next はループの先頭(条件)にジャンプしま
    す。

	exit (条件)
	next (条件)

    (条件) の指定のないばあいは無条件に行います。

	exit
	next

    go 命令のラベル指定の不要なもの、といえるでしょう。



５．５  ブロック名

      block または loop の文末に名前を置くことにより、そのブロックに
    名前を付けることができ、そのブロック内の exit, next の文末で名前
    を指定すると、多重ループ中でも指定されたループから抜け出すことが
    できます。

    例) loop BLK
		:
	    loop BLK2
		exit (bx) BLK	// 外側のループ BLK から抜ける
		:
		exit		// ループ・ブロック BLK2 から抜ける
		:
	    endloop
		:
	endloop (--cx)

      ブロック名はローカルの goto ラベルではないので、 go 命令で指定
    することはできませんし、next, exit で goto ラベルを指定すること
    はできません。

      ブロックの閉じたあとでは、一度使われたブロック名は再度使うこと
    はできません。




６．  条件式

      go,if,elsif,loop,exit,next で指定できる条件式についてです。
    今のところ４バイトのレジスタやメモリの比較には対応していません。

    生成されるソースのジャンプ命令のショート／ロングを自動判別するよ
    うなことはないのでプログラムを組む人がエラーにならないよう .w を
    指定する必要があります。

      条件は必ず() で囲まれないといけませんが、! （not）のみ () の外
    に指定できます。



６．１  演算子

      定数演算、式表現の命令、条件分岐で用いられる演算子の演算順位で
    す。

	 1. (式)  !式  ~定数式 -定数式 ++MR --MR &名前 %名前
	    sizeof(型を持つ名前)  defined(名前)
	 2. *  /  % .*.
	 3. +  -
	 4. <<  >>
	 5. < <= > >= .<. .<=. .>. .>=. .cf. .zf. .sf. .ovf. .pf.
	 6. ==  !=
	 7. &
	 8. ^
	 9. |
	10. &&
	11. ||
	12. = += -= &= ^= |= <<= >>= .>>=  .=.



６．２  jmpの基本命令を生成するもの

	(==)	!(!=)		je/	等しいとき
	(!=)	!(==)		jne/	等しくないとき
	(>)	!(<=)		ja/jnbe 大きいとき（符号無）
	(>=)	!(<)		jae/jnb 大きいか等しいとき（符号無）
	(<)	!(>=)		jb/jnae 小さいとき（符号無）
	(<=)	!(>)		jbe/jna 小さいか等しいとき（符号無）
	(.>.)	!(.<=.) 	jg/jnle 大きいとき（符号付）
	(.>=.)  !(.<.)  	jge/jnl 大きいか等しいとき（符号付）
	(.<.)	!(.>=.) 	jl/jnge 小さいとき（符号付）
	(.<=.)  !(.>.)  	jle/jng 小さいか等しいとき（符号付）
	(cf)	!(!cf)  	jc	cf がセットされているとき
	(!cf)	!(cf)		jnc	cf がクリアされているとき
	(zf)	!(!zf)  	jz	zf がセットされているとき
	(!zf)	!(zf)		jnz	zf がクリアされているとき
	(sf)	!(!sf)  	js	sf がセットされているとき
	(!sf)	!(sf)		jns	sf がクリアされているとき
	(ovf)	!(!ovf) 	jo	ovfがセットされているとき
	(!ovf)  !(ovf)  	jno	ovfがクリアされているとき
	(pf)	!(!pf)  	jp/jpe  pf がセットされているとき
	(!pf)	!(pf)		jnp/jpo pf がクリアされているとき

	(cx)	!(!cx)  	(jcxz合成)  cx が 0 でないとき
	(!cx)	!(cx)		jcxz	    cx が 0 のとき
	(--cx)  		loop	    --cx後 cxが0でないとき
	(--cx&&z)		loope/loopz
	(--cx&&!z)		loopne/loopnz



６．３  Rbwと０との比較

	(Rbw)			or Rbw,Rbw;jnz
	(!Rbw)  		or Rbw,Rbw;jz
	(Rbw ＃ 0)		or Rbw,Rbw;go (＃)

      '＃'は比較演算子で、実際には以下のものが指定できます。
	==  !=  >  <  >=  <=  .>.  .<.  .>=.  .<=.



６．４  cmp等を生成して、jmp命令を生成するもの

	(Rbw ＃ MRIbw)  	cmp Rbw,MRIbw; go (＃)

	比較演算子(＃)
		==  !=  >  <  >=  <=  .>.  .<.  .>=.  .<=.

	例)  go (ax > 5) LBL
	     go (bx .>. -3) LBL



６．５  代入演算命令を使うばあい

	(命令)  		|命令;jnz
	((命令) ＃ 0)		|命令;go (＃)

      '＃'は比較演算子で、実際には以下のものが指定できます。
	==  !=  >  <  >=  <=  .>.  .<.  .>=.  .<=.

      また、命令は以下のもののみ指定できます。
      （代入演算じゃないけど - , & も）

	MRbw-MRIbw	MRbw&MRIbw	MRbw+=MRIbw	MRbw-=MRIbw
	++MRbw  	--MRbw  	MRbw&=MRIbw	MRbw^=MRIbw
	MR|=MRIbw	MRbw>>=RIb	MRbw<<=RIb	MR.>>=RIb
	（adc(MRbw,MRIbw) sbc(MRbw,MRIbw) も使えるかもしれません）

	例）go (ax - 82 .>. 0) LBL
	    go (--cx .>. 0) LBL
	    go ((bx &= 0xfe) != 0) LBL
	    （代入演算子の順位が比較演算子より低いばあいは括弧が必要）



６．６  代入演算命令を使うばあいで、大小比較以外のフラグ変化を用いる

	((命令) ＃ 0)
	((命令) ＃ 1)

      '＃'は比較演算子で、実際には以下のものが指定できます。
	.cf.  .sf.  .zf.  .pf.  .ovf.

      指定できる命令は６．４と同じものです。

	例）go (ax - 5 .cf. 0) LBL
	    go (--cx .sf. 1) LBL



６．７  &&

	((条件1)&&(条件2))

      (条件1)と(条件2)が成立すれば真。(条件1)で偽ならば(条件2)をスキ
    ップするよう生成します。



６．８  ||

	((条件1)||(条件2))

      (条件1)か(条件2)が成立すれば真。(条件1)で真ならば(条件2)をスキ
    ップするよう生成します。



６．９  && と ||

      もちろん、&&, || は一緒に使って複数の条件を並べることができます。
	例） go ((ax == 0 && bx == 1 && cx == 2) || dx == 0) LBL

      が、((ax > 0 && bx) == 0) のようなことはできません。気をつけて
    ください（普段は大丈夫でせうが、マクロを使ったりすると^^;）

      ただ、&&,|| を並べたばあい以下のように、'!' を用いるとエラーに
    なるばあいがあるというバグがあります。
	例） go (ax == 0 && !(bx == 0 && cx == 0)) LBL
    これは、 go (ax == 0 && (bx != 0 || cx != 0)) LBL
    のように展開してやれば回避できます。

    '!' が現れるのが(条件)の一部の条件に付いたときだけみたいで、
	例） go !(si && (di == 0 || cx)) LBL
	     go (si && !di || cx == 0) LBL
    のような全体に対して、とか、一つだけ、なら、大丈夫なようです。
    （が、よくわかりません）



６．１０  .wの指定について

      .wが指定されると各条件ジャンプはショートジャンプで、行き先へは
    ロング・ジャンプ（ただの jmp）を１つだけ用意して中継します。
      命令に .w 指定されていても、その（条件）については生成されたソ
    ースはショートの範囲に納まるのを前提としているので、あまり一度に
    多くの条件を並べないでください。



６．１１  jcxz,--cx の生成

      go (cx == 0) LBL や if(cx) ..fi で jcxz を, loop (--cx) でloop
    を生成しますが、条件で && や || を用いたばあいこれらの命令をたい
    てい生成できません。生成したいばあいは分離してください。

      例) go (dx == 0 && cx == 0) LBL
	  ==>  if (dx == 0);go (cx == 0) LBL;fi

    ただ、ばあいによってはうまく jcxz を生成するばあいもあるかもしれ
    ません... そのように作ったつもりだけど、うまくいかなかったと^^;
    動作自体は同じだし...




７．  変数・定数・型の表現・宣言


７．１  定数ラベル

      定数ラベルは以下のように宣言します。

	    const 定数ラベル名［= 定数値］,……

      定数値は数値にならないといけません。定数値が省略されたばあいは、
    直前のラベルの値に１足した値になります。一番始めで省略されたばあ
    いは０になります。 Ｃでの const と enum 宣言のあいのこみたいなも
    のです。
      たとえば、
	    const C0,C1,C2,C3 = 100,C4
    ならば、C0 = 0, C1 = 1, C2 = 2, C3 = 100, C4 = 101 となります。



７．２  型（基本型）

      型はメモリの間接アドレス指定や変数宣言などで指定するのに用いま
    す。基本型としては、byte,word,dword があり、type文 や struct文で
    型の別名を定義したり構造体型を指定できます。

      byteは１バイトを、wordは２バイトを、dwordは４バイトを表します。
    また、基本型をtypeで別名登録したものも基本型とします。
      型の別名は、
	type  型名 = 型
    として定義します。

      byte,word,dword の別名として b,w,d を登録しています。 実際のと
    ころ byte,word,dword は使わずもっぱら b,w,d を使っています.

      あと、word と dword は、実は構造体でもあります。
      （構造体のところで、これは説明します）



７．３  メモリの指定方法（アドレッシング）

      直接アドレッシングやレジスタ・間接アドレッシングは、

	型[実行番地]

    で表し、セグメント・オーバライドを指定するばあいは、

	型[セグメント:実行番地]

    となります。

      たとえば、0x1000番地をword型でアクセスしたいばあいは、

	word[0x1000]

    となり、ESセグメントの bx + si番地をbyte型でアクセスする場合は、
	b[es:bx + si]
    となります。
      型は基本型、type,struct で宣言した型のことで、その場で直接配列
    型を指定することはできません。

      ちなみにレジスタ間接アドレッシングは以下のものがあります。
	[bx]		[bp]		[si]		[di]
	[bx+Ibw]	[bp+Ibw]	[si+IBw]	[di+Ibw]
	[bx+si+Ibw]	[bp+si+Ibw]	[bx+di+Ibw]	[bp+di+Ibw]
			    [bp]は実際には[bp+Ib]のIb=0 のばあいです。

      また間接アドレス指定でレジスタの指すメモリのセグメントは指定が
    ないばあい、bp があればss、 それ以外の bx,si,di および直接アドレ
    ッシングでは ds を用います。

      なお、xlat を生成する al = b[bx + al] は例外です。
    （それから、al = b[es:bx + al]のような、セブメント・オーバーライ
      ド指定はできません。seg_es 等を用いないと駄目です^^;... xlatが
      セグメント・オーバーライドできるなんて思ってなかったの^.^;）



７．４  変数

      変数はメモリに型情報とアドレスを持たせた名前で、データ・セグメ
    ントに配置されるもの、コード・セグメントに配置されるもの、手続き
    中でスタックに配置されるものがあります。


７．４．１  変数宣言

      変数はまず、以下のように宣言します。

	var   変数名:型,……	データ・セグメントに配置
	cvar  変数名:型,……	コード・セグメントに配置
	local 変数名:型,……	手続き内でスタックに配置

    var で宣言したものは _DATA（_BSS）というデータ・セグメントに、
    cvar で宣言したものは _TEXT （または、モジュール名@_TEXT）という
    コード・セグメントに配置され、local で宣言しものは bp 相対でアク
    セスでるように配置されます。
      cvarで宣言したものは、基本的には cs でセグメント・オーバライド
    されます。たとえば、cvar cv1:word で bx = cv1 なら、
	mov bx,word ptr cs:[cv1]
    が生成されます。

      local で宣言したものは、byte型変数以外は偶数アドレスに配置しま
    す。

      変数名は手続き外で var,cvar で宣言されものは、その名前（モジュ
    ール名が付加されるばあいもある）のラベルが生成されますが、手続き
    内変数は勝手にラベル名をつけて生成します。
      また、local で宣言されたローカル変数は、参照されるときに bp 相
    対の定数値が生成されます。


７．４．２  変数の初期化

      var,cvarで宣言する変数は以下のように初期値を与えることができます。
	var 変数名:型 = 定数式

７．４．３  変数のセグメント・オーバライド

      var vw:word で宣言された変数vw をes セグメントでアクセスするには
	word[es:%vw]
    のようにします.


７．４．４  変数の配置

      var や cvar で指定された変数が実際どこに配置されるかは保証しない
    ことにします。手続きと手続きの間で cvar で宣言したばあい、その変数
    が実際その場所にとられるか、別の場所に取られるか、決っていません。

      名前の順番は、

        cvar a1:w,a2:w,a3:w
        cvar a4:w

    とあるばあい、a1,a2,a3 は並んであるとしますが、a4 が a3 の直後にあ
    るとは限らないことにします（現在のana はその位置にありますが）。
       var のほうは、たとえ一つの var 宣言内であっても、初期値の有無で
    配置されるセグメントが代わるので、さらに気をつける必要があります。



７．５  配列

７．５．１  配列宣言

      型宣言や変数宣言で以下のようにすると配列を宣言できます。

	var  変数名:型(添字,添字,……)
	type 型名 = 型(添字,添字,……)

    添字を','で区切って並べれば多元配列を宣言できます。

      添字はすべて、定数値にならないといけません。
      添字はＣと同様に配列の要素の数で、アクセスするときは０から添字
    の値より一つ小さい番号までが有効です。


７．５．２  配列変数

      配列型で宣言された変数のアクセスは

	配列変数名(添字)
	配列変数名[実行番地]

    の２種類の方法があります。

      前者のばあい、添字は定数値でないといけません。たとえ配列の要素
    が１バイトであってもレジスタを指定することはできません。
    アクセスするアドレスは、

	配列の先頭アドレス + 配列要素サイズ * 添字

    で、そのアドレスを要素の型でアクセスします。

      多元配列のばあいは、var av:word(C1,C2,C3) とするとav(n1,n2,n3)
    は、

	word[%av + n1 * C2 + n2 * C3 + n3]

    と同じです。

      後者のばあい、添字を指定することはできませんが、レジスタなどを
    指定でき、アクセスするアドレスは、

	実行番地 + 配列の先頭アドレス

    で、そのアドレスを要素の型でアクセスします。

      前者・後者とも特別なばあいを除いて要素のサイズは１、２、４バイ
    トでないとエラーになります。


７．５．３  配列変数の初期化

      配列変数の初期化は以下のように、

	var 変数名:型(添字) = { 要素0,要素1,...}

    のようにして指定します。要素は定数式です。
      また、要素は基本的には必ず { } で囲んでやる必要があります。
      要素の数が添字よりも少ないときは足りない分を0でうめます。
      添字の指定のないときは、要素の数だけ指定されたことになります。
      初期値は、db,dw,dd 等が生成されます。


７．５．４  文字列による配列の初期化

      byte型の配列の初期化に限り、'"' で囲んだ文字列が指定できます。
    文字コードを並べたものとなり、byte型では全角（シフトＪＩＳ）は上
    位バイト、下位バイトの順におかれます。

      文字列と数値は順に並べることができ、文字列は後に'\0'を置くよう
    なことはしないので、必要ならば自前で'\0'を置く必要があります。

      例：var Ary:b() = {"ﾊﾞｲﾄ型文字列",0}

      ただし、byte型の文字列での初期化の例外として、{ } で括らずに文
    字列を指定すると文字列を展開したあとに後に'\0'を置きます。先の例
    を書き直すと次のようになります。

      例：var Ary:b() = "ﾊﾞｲﾄ型文字列"


７．５．５  サイズ０の配列

      サイズ０の配列を宣言でき、

      	var bv:b(),dwv:d

    のようなこともできます（処理系を騙すような感じですが）。
    
      これは、構造体の利用で、

    	struct StTyp
    	    len:w
    	    buf:b()
        endstruct
    
        var ary:b(1024+2)
    
    とあるとき、
        
        StTyp[%ary].buf(20) = al
    
    みたいなことをするためにサイズ０の配列を用意しました。



７．６  構造体

７．６．１  構造体型定義

      構造体型は以下のように定義します。

	struct 構造体型名
	    メンバ名:型 ,メンバ名:型
	    メンバ名:型
		:
		:
	endstruct

      区切るのに','と改行（';'も）が有り、あまりきれいな形じゃないで
    すが...
      メンバ名は構造体ごとに他の名前とは別の空間に登録しますので、他
    の構造体のメンバ名と名前が衝突することはありません。

      また、つぎのように,

	struct STRUCTYPE
	    memb1:byte
	    memb2:word
	    ++
	    memb3:word
	    memb4:byte
	    --
	    memb5:dword
	    --
	    memb6:byte
	    memb7:byte(3)
	    ++
	    memb8:word
	endstruct

    のように'++'でくぎると、次の'--'でくぎられたものが、'++'の位置の
    ものに重なるように配置されます。この例では
	+0	+1	+2	+3	+4	+6	+7	+8	+9
	memb1	memb2	---	memb3	---	memb4	X	memb8	---
				memb5	---	---	---
				memb6	memb7	---	---
    というふうに配置されます。
      '++'が現れる前に'--'が指定されたばあい、先頭(0)になります。

      あと、構造体のメンバとして他の構造体型を指定することもできます。


７．６．２  構造体変数

      構造体型で宣言された変数が構造体変数になります。
      基本的に構造体は必ずメンバ名を指定してアクセスします。

      構造体メンバは以下のように指定します。

	構造体変数名.メンバ名

    たとえば、

	StVar.memb
	StAry(0).memb	 //配列のばあい

    となり、もしメンバが配列ならば、

	StVar.memb(1)

    とし、メンバが構造体なら、

	StVar.memb.memb2

    のようにしてください。

    また、型名と実行番地によるアクセスは、

	StMem[実行番地].memb

    となります。


７．６．３  構造体の初期化

      構造体の初期化は data 〜 enddata を用いてください。


７．６．４  登録済み構造体

      実は word と dword は構造体でもあり、 以下のように定義されたも
    のとしています（実際には内部では特別に処理してます）。

	struct word;  l:byte, h:byte; endstruct
	struct dword; l:word, h:word; endstruct

    もちろん l,hはメンバ名であり、他の名前と衝突することはありません。
      l は low byte(word), h は high byte(word) をアクセスするときに
    用います。たとえば、

	word[si].h  DWordVar.h  dword[bx].l.h

    とかで、それぞれ（DwordVarの型はdwordとすると）、

	word[si+1]  dword[%DWordVar+2]  dword[bx+0+1]

    としたのと同じです。



７．７  data 〜 enddata  （配列・構造体変数の初期化など）

      構造体変数の初期化はちょっとぶざまで不気味です(^_^;)。
    以下のようになります（実は構造体だけでなく配列にも指定できます）。

	var 変数名:構造体型 = data
	    基本型  初期値....
	    基本型  ...
		:
		:
	enddata

    初期値は定数式で、たとえば、

	struct StTyp; name:b(10), atr:w, atr2:w; endstruct

    のとき、

	var StVar:StTyp = data
	    b  "test",0,0
	    w  0,0
	    w  3,5
	enddata

    というふうにします。
      見ての通り data 〜 enddataの間は構造体の定義に依存せず（できず）、
    いちいち型を指定してデータを並べる必要があります。ただし、構造体
    のサイズ以上には設定できず、構造体のサイズよりも少ないばあいは残
    りを０を埋めます。
      実は基本型名の後に配列宣言のように()でその行で定義するデータの
    最大個数を指定することができ、()で示したサイズに満たないばあいは
    残りを０で埋めるので先の例は次のようにかけます。

	var StVar:StTyp = data
	    b(10)  "test"
	    w	   3,5
	enddata

    ただし、基本型名と'('の間にスペースを置くことはできません。また、
    多元配列にもできません。

      '++'や'--'があるため初期値の型を決めるルールがめんどくさくやや
    っこしくなるから、このほうがアセンブラとしては楽じゃないかなって
    ことでこうしましたが、実は、初期化のルーチンを付け足す段になって
    現在のメンバ名の管理ではメンバの順番の情報を持っていないことに気
    ずき、苦肉の策だったりします^_-;。

      data〜 enddataは構造体・配列の初期化だけでなく、プログラム中に
    直接コードを置くのにも使えます（db,dw,ddを生成します）。



７．８  その他の演算など


７．８．１  ww()

      これは、dword 型の項目を即値、２バイト型のメモリ・レジスタ（セ
    グメント）を混ぜて指定するのに使い、

	ww(MRIw1,MRIw2)

    となります。たとえば、

	dx.ax = ww(es,&buf)	==>  ax = &buf;dx = es
	ax.di += ww(0xA000,si)  ==>  di += si; adc ax,0xA000

    というふうになります。



７．８．２  オフセット値（%）

      変数名や構造体メンバ名の前に'%' を付けることによりそれらのオフ
    セット値を求めることができます。

	%name

    で、nameが var, cvar や手続き名で定義されたものならMASMの

	offset name （実行番地を表す式中では単に name）

    に展開され、ローカル変数や構造体のメンバ名ならオフセットを表す定
    数値になります。

    構造体メンバの指定方法は、
	%構造体型名.メンバ名
	%構造体変数名.メンバ名
    です。

      また、var やcvar、セグメント名につけるとそのセグメントの値とな
    ります。たとえば、

	ax = %var	==>	mov ax,DGROUP
	dx = %cvar	==>	mov dx,_TEXT

    というふうになります。



７．８．３  アドレス演算子（&）

      変数名や 型[実行番地] の前に'&' をつけると、そのアドレスを求め
    る式になります。

      var や cvar で宣言された変数につけられると、 '%'を付けたのと同
    じことで ofset 変数名 （実行番地を表す式では単に変数名のみ）に変
    換されます。

      型[実行番地] やローカル変数につけられるのは word 型への代入(=)
    の右辺のみです。lea [実行番地]を生成します。



７．８．４  文字列

      &VarName の置ける場所に "文字列"を置くことができ、そのアドレス
    を値とします。たとえば、
    	
    	ax = "文字列"
    	PutStr "メッセージ"	//PutStr を手続きとするとき

    のようにできます。

      この文字列は%var のセグメント _DATA に置かれます。また、文字列
    の最後には必ず'\0' が付きます。 手続き中に現れたこのような文字列
    を溜めておき手続きが閉じたその後ろに生成します。

      セグメントが固定され、かならず'\0'がついたりして、自由度は低い
    ですが、それらを代えたいばあいは配列変数にして行なってください。
      はじめは文字列は必ず var や cvarで配列にして使うのみにしようと
    してましたが、変数の宣言できる位置は決められており表示のメッセー
    ジ等を指定するときめんどくさいので、楽するために用意しました。



７．８．５  型抽出（typeof()）

      typedef(変数名)にすると、その変数の型を表すことになります。
      たとえば、struct StTyp  m1:byte,m2:word で var v1:StTyp なら、
    typedef(v1)[bx+si].m2 や var v2:typedef(v1) のようにして型として
    使えます。



７．８．６  カレント・アドレス (*)

      式中の定数値やラベルの位置にある'*' は、生成されたソースでの一
    命令の先頭アドレスを値とします。
      単純にMASMでの'$' に変換するだけでなんら調整をおこなわないので、
    基本命令以外で使わないでください（合成命令で使われてもチェックし
    てません）。




８．  手続き

      ａｎａでは call LBL とするかわりに Ｃみたいに、 LBL() で呼び出
    せる手続きが使えます。っというより、プログラムは手続きの集まりで、
    手続き外に命令を書くことはできません。



８．１  手続き定義

    手続きは以下のように定義します。

	proc 手続き名(引数1,引数2,……)
	    （指令）
	enter または begin
	    （ローカル宣言）

	    （手続き本体）
	endproc

      endproc は手続きの終わりを示すだけで、ret を生成するようなこと
    はないので、必ず、ret や return を使う必要があります。



８．２  引数

８．２．１  引数の宣言

      引数並びには、レジスタと、手続き内でローカル変数となるスタック
    に積んでくるものがあります。
      レジスタは byte 型レジスタも指定できますが、スタックに push さ
    れる分は word 型と dword 型しか指定できません。

      レジスタはそのままレジスタ名を指定します。
      スタックに積む引数は、変数の宣言と同じで、
      	変数名:型
      です。
      
      たとえば、手続き定義の１行目は、

	proc 手続き名(cl, bx, dx.ax, pv1:w, pv2:d)

    というような感じになります。

      基本的には引数の数は固定されますが、可変引数を用いることもでき
    ます（説明は後述）。


８．２．２  手続き呼びだしでの引数への暗黙の代入

      手続き（手続きマクロ、repの付くストリング命令も含む）は、 引数
    が変数の形で宣言されていれば push し、レジスタが宣言されていれば
    そのレジスタへの代入を行ないます。
    
      たとえば、

      	proc Pr(ax,bx,p1:w)

    が宣言されていれるとき、

    	Pr  2,bx,cx

    を行なうと、

    	push cx
    	ax = 2	//mov ax,2
    	call Pr

    になります。bx = bx は生成されません。



８．３  指令

      指令には以下のものがあります。
	cdecl
	far

８．３．１  cdecl

      名前の通り基本的には(標準的な?)Ｃの関数のためにあります。
      cdecl の指定のないばあい、スタックに積まれた引数はret N を用い
    て手続き側で削除して復帰します。
      cdecl を指定すると、そのようなことは行なわず、呼びだし側でスタ
    ックを捨てるようになります。

      注意する点としては、cdecl を指定したばあい、フラグ返しはできま
    せん。スタックを捨てるのに  sp += N を実行するので、折角返したフ
    ラグを破壊してしまいます。


８．３．２  far

      その手続きがmodelに関係なく far call されるようにします。



８．４ enter と begin

      enter か begin があると それ以降に手続き本体があることになりま
    す。

      enter だと、手続きの入口でローカル変数を確保したり bp を設定し
    たりする命令を必ず生成します。手続き内部では enter が使えません。

      begin は bp によるスタックをアクセスしない場合に指定でき、余計
    なスタック・フレームを生成させず、return は leave(sp = bp;pop bp)
    を生成しません。
      とうぜん、 bp の使用は自由です。enter,leave の扱いも本来のもの
    です。
      手続き引き数をスタックにとらずローカル変数を使わないばあいのみ
    使用可能です。(save したレジスタに名前を付けた場合もローカル変数
    と同じなので気を付けてください）



８．５  ローカル宣言部（save,local）

      ローカル宣言部では以下のものが指定でき, これら以外の命令が現れ
    ると宣言部を終わります。

	    save  ﾚｼﾞｽﾀ1,名前:ﾚｼﾞｽﾀ2,……
	    local ﾛｰｶﾙ変数名:型 ［=初期値］,……
	    const 定義
	    var   定義
	    cvar  定義
	    type  定義
	    struct 定義

      save と local 以外は手続き外での宣言と同じなので省略します。


８．５．１  local

      local はすでに説明してるとおりスタック上に配置されます。初期値は
    指定されると、領域確保のとき初期値を push します。初期値はレジスタ
    で 186モードならば定数式も指定できるでしょう。この初期化は、引数に
    指定されたレジスタをローカル変数にするために用意しました。

      local は proc〜enter〜endproc で使用でき、proc〜begin〜endproc
       では使用できません。


８．５．２  save

      save は、その手続きの入口で pushし、リターンするときにそのまま
    復活するレジスタを指定します。
      enter 〜 endproc では、enter の処理をする前に push します。
    （return のときは、leave を実行したあと pop することになります）。

      以下のものが指定でき、pushする順番は固定で、指定されたもので下
    記に該当するものを右から順に push します（pushaに似せています）。
		      ~~
      fx,es,ds,di,si,bx,dx,cx,ax

      このほかに、pushaを save のパラメータに与えると pusha を生成し
    ます。  pusha に含まれるレジスタも一緒に指定しても生成されるのは
    １つです。

      例） save pusha,fx,ds

      注意する点として、save で指定された pusha の動作は、ＣＰＵのモ
    ードが 8086 か 186 かで若干違います。
      186 では単に pusha を生成するだけですが、8086 では、sp,bp を
    push しません。つまり、sp,bp の扱い、消費するスタックの量に違い
    があるので、その違いに影響しないようにプログラムしませう。
    （なお、save 以外での pusha は 8086 モードでも 186 と同じように
      sp,bp をpush するので安心してください）

      またこのpushしたものに名前をつけてローカル変数としてアクセスし
    ます。もちろん、不用意に書き換えると不幸でしょう。

      例) save pusha, sav_ax:ax, sav_ds:ds


      save で push したレジスタを pop するのは load か return です。



８．６  手続き中のプログラム

      手続き本体部に、実際のコードを書きます。
      手続き用に以下の命令があります。

	load
	return


８．６．１  load

      手続き宣言部で save 命令で push されたレジスタを popする命令で
    す。
      たいてい、return を使うのでまず使うことないでしょう。


８．６．２  return

      return は、手続きからもとのルーチンに復帰するためのもので、 ロ
    ーカル変数があればその領域を開放し、 save で push されたものをも
    とのレジスタに pop してから、ret をおこないます。
      enter 〜 endproc では、必ず leave (sp = bp;pop bp) を生成しま
    すが、begin 〜 endproc では生成しません。

      つまり、enter指定の手続きでは leave;load;ret を行うことになり、
    begin 指定の手続きでは load;ret を行うことになります。

      生成される ret は引数がスタックを使っていればそれを削除するよ
    う定数付で生成されますが、cdecl が指定されていると呼び出し側でス
    タックを削除するので単に ret のみを生成します。



８．７  手続き宣言

      ａｎａは１パスなので、手続き呼び出しを前方参照しようとするばあ
    い、あらかじめ手続きのインターフェースを宣言しておく必要がありま
    す。
      手続き宣言は単に手続き定義で enter,begin と本体を書かずに、
    endproc を書けば手続き宣言になります。もちろん手続き宣言と手続き
    定義は矛盾してはいけません。



８．８  手続き呼び出しのときの丸括弧の省略

      手続き呼び出しでは、'(' ')' を省略することができます。
      また、ストリング(rep)命令や, com,neg,adc,rol,div などは、if な
    どに条件式中に（関数的に）使われるのでなく、手続きのように、その
    命令だけを置くばあい、これらの'(' ')'も省略することができます。



８．９  可変引数

      引数宣言で、最後の引数を

	...引数名:型()

    のようにすると、その部分が可変長引数になります。
      ただし型は byte か word 型です。
    たとえば、

	proc 手続き名(pVar1:word, ax , ...arg:w() )

    のようにすれば、word型のローカル変数（ただしサイズ０）として、可変
    引数部を扱えます。

    さらに、

	...引数名:型(レジスタ)

    とすると、手続きを呼び出す側で可変引数の配列の要素数を指定したレジ
    スタにいれて呼び出すようになります。レジスタは byte か word 型だけ
    です。

    呼びだしにおいて可変引数部には、word 型か dword型が指定でき、dword
    型は word 型の引数を二つ並べたことになります。
    つまり、レジスタでわたされる可変引数の要素数は可変引数の数でなく、
    そのサイズ(byte単位かword単位)をあらわします。
    可変引数部だけではdword か word のどちらが積まれたか判別することは
    できません。
    型として byte または word 型が指定できるのは、受け取った側で処理す
    るのに都合のよい単位にするためです。
    たとえば、

	proc Pr(si, ...arg:b(cx))

    で、

	Pr (si, ax,bx,dx)

    なら cx = 6 が call の直前に行なわれ、

	proc Pr(si, ...arg:w(cx))

    で

	Pr (si, ax,bx,dx)

    なら cx = 3 が call の直前に行なわれます。

    なお、可変引数部のスタックの消去は呼びだし側で行ないます。
    可変引数部でない引数でスタックに積まれたものの扱いには影響しませ
    ん。それらは cdecl指定の有無に従います。つまり、可変引数部のある
    ばあいは、たいがい cdecl を指定したほうがお特です。



８．１０  手続きマクロ

      手続き定義で、enter,begin のかわりに macro を指定すると、手続
    きでなくマクロになります。
      ただしこれは中途半端なしろもので（挫折した^^;）、ほとんど使え
    る命令がありません。

      基本的に式表現の命令(rol,com等も含む), push/pop, intr のみで
    ジャンプ・コール関係（制御命令）やストリング命令は指定できません。
    手続き引き数にマクロのためのパラメータを指定することはできません
    し、引き数のローカルラベルを指定することもできません。

      もともと別の目的（廃案にした ^^;）で付けたもので、そのついでの
    しろもので、Dos のファンクション・コールを手続きのようにするため
    に用意しました。

      マクロとしては別に @define でＣの #define と同じようなものを用
    意してあります。




９．  '@' 命令

      Ｃの '#'で指定するプリプロセッサ命令に似たものを用意してありま
    す。
	@if
	@elsif
	@else
	@fi
	@define
	@include
	@set
	@print

      これらの命令は当所付けるつもりはなく、ＣＰＰを流用するつもりで
    したが、内臓したほうが何かと便利なので用意しました。
      ただし強引に付加したので、かなり妖しい部分があります。

      これらは、Ｃとちがいプリプロセスではなく、複雑にその他の部分と
    からみあっているので気をつけませう。


９．１  条件コンパイル

	@if 条件
	   :
	@elsif 条件
	   :
	@else
	   :
	@endif

      上から順に評価していき条件の成立したブロックを生成し、他は生成
    しません。もちろん、@elsif, @else は省略可能です。

      条件コンパイル命令は他の命令とおなじように解析されます。つまり、
    命令の置けるところで指定できます。つまり１行に並べてしまうことが
    できます。

      例）  @if defined(name);push ax;@fi

    また、定数演算はすべて行えます。

      そのかわり、ＣのＣＰＰのように、文の途中に用いることはできませ
    ん.
      例） × ax = @if
		10
	      @else
		20
	      @fi
	      はできません。

      ただし例外として、

	proc Name(引数)

    を
	proc Name
	 @if defined(name)
	   (引数)
	 @else
	   (引数)
	 @fi

    のようにはできます。

      それから、module 外では使用できません。
      また、proc〜endprocの対応を替えるようなことはできません。


９．３  @setによる定数設定

      @set は、

	@set 定数ラベル名 = 定数値

    で、定数ラベル名に定数値を設定します。まあ、const 定義と同じよう
    なものですが、const では、定数ラベルの値を再設定できませんが、
    @setでは行えます。しかも、宣言部以外のプログラム本体の途中でも使
    えます。
      手続き外なら、グローバル、手続き内でならローカルな名前になりま
    す。
      でも、あまり使い道はありません(^^;



９．３．１  8086/186(V30)モードを示すラベル

      P86 という定数ラベルが 8086 か 80186(V30) モードかの値を保持し
   ています。
      P86 が 0 なら 8086モード、1 なら 186(V30)モードとなります。
      8086/186の指定はコマンド・ラインのオプションで指定できますが、
    プログラム中で @set 命令で .P86 に 0 か 1 を指定することができま
    す。
      @set で設定されるごとに .186 などが生成されます。
      手続き中での切り替え、そのまま手続きが終わるとスタックレベルの
    調整がくるったりしますので、手続き中では設定しないでください。



９．４  @print

      コンパイル中に画面にメッセージを表示させるためのものです。
	@print "文字列",12,1+C2,"文字列2"
    のように文字列と定数を ','で区切ってならべて指定できます。



９．５  @define マクロ

      Ｃのように

	@define マクロ名(引数)  展開する文字列

    で引数付きのマクロが定義できます。が、手続き内では定義できません。
    Ｃとちがい引数のないばあいは

	@define マクロ名()	展開する文字列

    のように()を引数なしで付けてください。

      引数は 7つまでです。

	@define Mac(a,b,c)	if(a == b); a = 0; else; a += c; fi

    って感じで指定します。


      このマクロはかなり強引にサポートしたのでかなり妖しいです。

      Ｃと違い前処理系ではありません。マクロ名に、ana の予約語は使え
    ません。

      同じマクロ名や互いに呼び合うマクロ名を展開する文字列中に含める
    とメモリ不足で止まってしまいます。

      マクロを指定するときは、手続きと同じように(...) を省略可能です
    がなるべくなら、省略しないでください。バグがあり、引数指定したマ
    クロ命令の後ろに ';' を用いて文を置くと、マクロが誤って展開され
    ます。たとえば、上の Mac を用いて

	Mac 20,10,20; ax += cx

    とすると Macの展開に失敗するので（エラーもでません）、このばあい、

	Mac(20,10,20); ax += cx

    のようにしてください。
      マクロの後ろに文を置かず行を代えれば、

	Mac 20,10,20
	ax += cx

    は大丈夫です。

      ちょっと気持ち悪いかもしれませんが、

	@define DEB()	@if defined(DEBUG);putstrChkMsg;@fi

    のように展開する文字列中に @if等を含めることができます。

      あと、バグとして、

	@define TITLE	"title"

    のとき、

	var msg:b() = TITLE " -- "

    なら、うまく展開され文字列は連結されるのですが、

	var msg:b() = " -- " TITLE

    のように指定するとエラーになります。文字列連結時に、TITLE が文字
    列に展開されてないのです^^;...
    強引に付加した機能なのでこういうこともあると^^;

      なお、文字列初期化では

	var:b() = " -- " TITLE

    に等しいことをしたいばあいは、

	var:b() = {" -- ",TITLE,0}

    とすればうまくいきます。



９．６  @include

	@include <ファイル名>
	@include "ファイル名"

     Ｃの #include と同様の機能です。ソースファイルを取込みます。

     が、ana では、import 文があるので、あまり使うことはないようにも
   思います...





１０．  ファイル、モジュール関係


      ａｎａのソース・ファイルは必ず、module で始まり endmodule で終
    わります。

	module  モジュール名
	    <モジュール宣言部>
	    
	    import モジュール名
	    	:
	    	:
	 
	    <変数・定数・手続きなど各種宣言>
	 	:
	 	:
	endmodule

      モジュール名は省略不可能です。



１０．１  輸入・輸出

      他のモジュール（ファイル）の変数や手続きにアクセスするにはまず、
    そのモジュールを import 文で指定してやる必要があります。
      輸出する側（importされるモジュール）では、輸出する名前の宣言の
    前に'*' を置いて指定します。指定できる宣言は、

	type
	struct
	var
	cvar
	const
	proc
	@define
	segment

    で、たとえば、

	*var v1:word,v2:word
        *proc ProcName(ax)
        	endproc
        *@define ADD(a,b)	a+=b

    のようになります（*@define はちょっと見苦しいですね^^;）
    '*' の付いていない宣言の名前は輸出されません。
    
      そして、importした側では輸入した名前は必ずモジュール名を付けて

    	モジュール名.名前

    の形でアクセスすることになります。
    
      たとえば、

    	module Dos
    	    *const STDIN,STDOUT,STDERR
    	    *@define Exit(c)	al=c;ah=0x4c;intr 21h
    	    *proc Read(bx,dx,cx)
    	    macro
    		ah = 0x3f;intr 0x21
    	    endproc
    	endmodule
    
    というモジュールが dos.ana というファイル名であるとき、
    	
    	import Dos
    
    で輸入し、
      
    	Dos.Exit(1)
    	Dos.Read Dos.STDIN, dx, cx
    	ax = Dos.STDERR
    
    のように使います（２つ目のDos.STDIN は少々情けないがガマンしてね）


      輸出で気をつけなければならないのは、輸出する変数の初期値やマクロ
    （手続きタイプ、@define共）中に輸出していない名前を含めてはいけな
    いということです。
      ただし、proc で定義したマクロに関しては、定数ラベルは数値に直し
    たのち輸出するので少しマシです。



１０．４  モジュール名の別名定義

      モジュール名は type を用い、

      type 別のモジュール名 : モジュール名

    として別名を登録できます。



１０．５  輸出する名前

      輸出した先では、変数名や手続き名などの名前は構造体のメンバ名と
    同じような扱いになるので、予約語と同じ名前にしても大丈夫というこ
    とになるので、実は、各宣言において、予約語と同じ名前で宣言するこ
    とができます。ただし、宣言したモジュール内でアクセスするときは、
    そのままでは予約語と衝突するので、importしたものと同じようにその
    モジュールの名前を用いて指定する必要があります。



１０．６  import するファイル

      import の指定は基本的には
      
      	import モジュール名
     
    で、importするモジュールのファイル名はモジュール名と同じであると
    前提していますが、MS-DOSでは（拡張子を除くと）８バイトしかありま
    せんし、大文字小文字の区別がないので、少々困ります。そこで、
	
	import モジュール名:"ファイル名"
    
    のようにして、ファイル名を別の名にしても指定できるようにしていま
    す。ファイル名は、拡張子を省くことができます（後述）。
      ただし、importする方、される方で、モジュール名は一致しないとい
    けません。
    
      あと、Ｃと同じように、
    
    	import モジュール名:<ファイル名>
    
    で、ヘッダ用のディレクトリより探すようになります。


      import するファイルの拡張子は、ファイル名が指定がないばあいや
    指定されたファイル名に拡張子がないばあい、まず、".han" という拡
    張子を付けて探し見つかればそれでよし、見つからないばあいは".ana"
    という拡張子をつけて探します。
      さがすディレクトリは、まず、カレントまたは指定されたパスを探し
    なければ、<ファイル名>用のディレクトリより探します。もちろん、最
    初から <ファイル名> が指定されていればそのディレクトリのみ探しま
    す。
      もし、ファイル名の指定で".han"以外の拡張子が指定されたばあいは
    まずその拡張子のまま探し、なければ".ana"にして探します。

      あと、
      
	import モジュール名:".拡張子"

    とすれば、"モジュール名.拡張子" というファイル名が指定されたとし
    て探します。



１０．７  importの多重読み込み

      import するとき、基本的に輸入先のファイルにあるimport 文は無視
    し、ファイルを読みにいきません。
      しかし、輸入する定数やマクロなどで、モジュール外の名前が使われ
    たり使いたかったりするばあい不便なので、
      
      *import モジュール名
    
    と'*' を付けることで、import先でさらにimport します。

      '*' 使っているのでまぎらわしいですが、もともとのモジュールに、
    それらのモジュール名が輸出されるわけではありません。
      たとえば M0 というモジュールから M1 というモジュールを読み込み
    そのなかで *import M2 として M2 を読み込むことがあっても、 M0 で
    は M2 というモジュール名でも M1.M2 というふうにしても、アクセス
    できません。別にM0内で import M2 をする必要があります。

      ただし、一度 import したモジュールの内容は保持し、どのモジュー
    ルで import したにかかわらずモジュール名を１つの表に登録しておき、
    import するときに すでに読み込まれたモジュールなら新たにファイル
    を読みに行くようなことはしません。
      モジュール名は階層にならないので名前の衝突等には気を付けてくだ
    さい。



１０．８  モジュール宣言部

      モジュール宣言部には以下のものが指定でき、それら以外の命令が現
    れると終了したことになります。

	model  モデル番号
	start  手続き名
	stack  スタック・サイズ
        c_name "モジュール名文字列", "ｾﾊﾟﾚｰﾀ",Ｃフラグ

      これらは各１つしか指定できませんが、省くことはできます。
      なお、これらのあと、import 文が続き、import 以外の文が現れた時
    点で変数や手続き等の処理になります。


１０．８．１  model  モデル番号

      コンパイル・モデルを指定します。番号の値は、
      	
      	0	TINY
      	1	SMALL
      	2	COMPACT
      	3	MEDIUM
      	4	LARGE
    
    です。省略時は、1 。なお、TINYとかSMALL いう名前は定数ラベルとし
    て登録されています。後述します。



１０．８．２  start 手続き名
      
      start ではプログラムの一番最初に実行する手続きを指定します。こ
    の命令はプログラム内で複数指定さないでください。
      実際には、生成したソースの終りに
	
	end 手続き名
    
    を生成するだけです。



１０．８．３  stack サイズ
      
      _STACKセグメントに取るセグメント・サイズを指定します。この指定
    がないと_STACKセグメントは生成されません。



１０．８．４  c_name "モジュール名文字列", "セパレータ",Ｃフラグ

      グローバルな変数名や手続き名の生成される名前は、c_nameの指定の
    ないばあい、出力するアセンブリ・ソースには、

	モジュール名@名前

    というふうに名前にモジュール名が付加されます。
      
      たとえば、モジュール名 test のモジュールで, *var v1:wordと宣言
    されたばあい、v1 は test@v1 という名前に変換されます。
    
      c_name ではこの生成される'モジュール名'を変更するためにあります。
    またモジュール名と名前の間に置くセパレータ文字も変更できます。
      モジュール名は 20文字前後、セパレータは 2文字までです。
 
	例) c_name "tst","$"で var 変数 v1 は、tst$v1 に、
	    c_name "","_" で var 変数 v1 は、_v1 になります。


      Ｃフラグは、Ｃの手続き名はたいてい生成される変数・手続き名の頭
    に'_' を付ける必要があるので、それを自動的に付加するためにありま
    す。
      ０なら付加せず、１なら頭に'_'を付加します。２ならLSI-C用に名前
    の後に'_' を付加します.
      Ｃの手続きを各場合は c_name "","",1 のようにすればよいでしょう。
    （または c_name "Mod","_",1 のようにセパレータを'_' にしてモジュ
      ール名を付けるのもいいかも）

      なお、c_name ,,1 のように他の指定を省略することができます。




１１．  メモリ・モデル、セグメント関係


１１．１  model
 
      model はそのモジュールのメモリ・モデルを指定します。

	model 0〜4

      指定できるモデル名は次のものがあり、数値で指定しますが、定数ラ
    ベル名としてモデル名が定義されています。

	  ラベル名
	0 TINY      （CS = DS = SS  near call）
	1 SMALL     （CS , DS = SS  near call）
	2 COMPACT   （CS , DS , SS  near call）
	3 MEDIUM    （CS , DS = SS  far  call）
	4 LARGE     （CS , DS , SS  far  call）

      各モデルの括弧内のセグメントは、そのモジュールが前提としている
    セグメントの配置で、実際に生成されるソースでは, segmentやDGROUP,
    assume の生成などに関係します。
      near call, far call は、他のモジュールから呼ばれる（他のモジュ
    ールに輸出する）手続きが near であるか far であるかを示します。
      基本的にどのモデルであろうとも、モジュール内でしか呼ばれない手
    続きは near call になります。
      TINY,SMALL,MEDIUM はほぼ他の高水準言語と同じようになりますが、
    COMPACT と LARGE は若干違い、また HUGE モデルはありません。
      この宣言にしたがい、各手続きの始めに assume 命令が生成されます。

      var 宣言された変数はどのモデルであろうとも DGROUP のセグメント
    に配置され、cvar 宣言されたものは _TEXT（モジュール名@_TEXT）に
    配置されます。
      far (HUGE) 領域に確保するデータはプログラマが segment 宣言でセ
    グメントを定義しなければいけません。

      model 命令自体を省略すると、コマンド・ラインで指定されたモデル、
    それさえもなければ model SMALL、が指定されたことになります。
      輸出先のモデルの影響はうけません。



１１．２  .comファイルについて

１１．２．１  .com ファイルの作成

      ａｎａは .com プログラムの作成は苦手です。

      たぶん直接 生成されたソースをいじることになるでせう。
      model での TINY 指定は、セグメントの指定をするのみで、COM ファ
    イル作成の命令というわけでないので気を付けてください。


１１．２．２  org
      
      いちおう、com ファイルのために
      	
      	org オフセット

    があります。これは、コード・セグメントに生成するだけで、他のデー
    タ・セグメント等には指定できません。
      指定は手続き外でのみ行なえます。まあ、ファイルの変数宣言や手続
    き宣言お行なうより先に指定するのが無難でせう。
      生成されたソースを確かめてください.


１１．３  segment

      segment セグメント名  アライメント,コンバイン,"クラス"

    または、

      segment セグメント名:esまたはcs アライメント,コンバイン,"クラス"

    で、segment 命令を生成します。各項目は省略できます。

      アライメントには、

      	byte, word, para, page

    が、コンバインには

    	public, private, common, stack, 定数値

    が、"クラス" は

    	"文字列"

    が指定できます。

      コンバインの定数値指定は、at 定数値  指定が生成されます。

      segment で定義したセグメント名は、var や cvar と同じように、

	セグメント名  変数名:型,……

    で、そのセグメントに変数を定義できます。たとえば、

	segment FarVar word,public,"FAR_DATA"

    として、

	FarVar  fv1:word,fv2:byte(0x8000)

    のようにできます。

      segment 定義自体は、手続き内では定義できませんが、定義されたセグ
    メントで変数を定義するのは手続き内でも行えます。

      レジスタなどにセグメントを設定するばあいは、オフセット値を得る
    ための'%'を用いて、
    
	%FarVar
    
    のように指定します。
    例）es = ax = %FarVar

      セグメント名に':'をつけ、es か cs を指定すると、変数のデフォル
    トのセグメント・オーバライドを設定できます。（ds,ssは不可）
      
      segment FarVar:es word,public,"FAR_DATA"
      FarVar vf1:word
    
    なら、ax = vf1 で、mov ax,word ptr es:[vf1] が生成されます。

      セグメント名の変わりに、var や cvar を指定すれば、それらの設定
    を変更できます（var, cvar の実際のセグメント名を変更することはで
    きません）。
      が、アライメント以外の変更な副作用があるのでしないでください。



１１．４  var,cvar のセグメント
      
      var は、初期値があれば、_DATA セグメントに, なければ _BSS セグ
    メントに配置します。_DATA , _BSS はかならず DGROUP に所属します。
      %var で生成されるのは、DGROUPです。

      cvar は、_TEXT か、モジュール名@_TEXT で、%cvar で生成されるの
    は TINYモデルでは、DGROUP, SMALL,COMPACTでは、_TEXT, MEDIUM,LARGE
    ではモジュール名@_TEXTとなります。

      segment 命令では、var やcvarの実際のセグメント名を指定すれば設
    定を変更することはできてしまいますが、ぜったいに変更しないでくだ
    さい。



１１．５  生成されるセグメント
      
      segment で定義されたセグメント名で変数を宣言したときに生成され
    る segment〜ends は、 同一のセグメントでの宣言が続いているとひと
    まとめになります。
      
      FarVar fv1:word,fv2:byte,fv3:byte
      FarVar fv4:byte(10)
      TstVar tv1:word
      FarVar fv5:word,fv6:byte
    
    なら、fv1〜fv4 が一つのsegment〜ends に入り、次に tv1 のみのsegment
    〜ends が生成され、そのあと、fv5,fv6のものが生成されます。
    このように、FarVarの途中のTstVarがFarVarを分断してしまいます。

      public宣言なら別段問題ありませんが、このルールは将来変わること
    があるので、private はまだいいとしても、 common はまず使いものに
    なりません。
      var では、初期値の有無で _DATA,_BSS に切り換わるのでより複雑に
    なります。cvar は、プログラム領域と隣あえば、一つの範囲に入ります。
      とにかく、順に生成して、セグメントが切り換わらないかぎりそのま
    まです。とくに、手続き宣言自体では切り換わらず、プログラム実体が
    生成される段になって、コードセグメントにするので、手続き外の変数
    宣言と手続き内の変数宣言がくっつくようなこともあります。



１１．６  even

      変数宣言や、手続き定義の前に even を置くとソースに even を生成
    します。もちろんアライメントが byte だとエラーになるでせう。



１１．７  assume
      
      assume 命令は、 アセンブラにセグメントの状態を知らせるための命
    令でａｎａは単にターゲット・アセンブラの assume 命令を生成するだ
    けです。
      
      assume セグメントレジスタ:セグメント名,……

      セグメントレジスタは、cs,ds,es,ss で、セグメント名は、segment 
    命令で宣言したものと、var,cvar,nothing のみです。
      var を指定すると DGROUP に、cvar を指定すると CGROUP（またはそ
    のモジュールのコードセグメント名）になります。
      nothing はセグメントレジスタが特定のセグメントを示してないこと
    になります。
      assume nothing ですべてのセグメント・レジスタに nothing を指定
    したことになります。

      実は実際にどの程度使うのかよくわかっていません^^;




